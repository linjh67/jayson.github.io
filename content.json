{"meta":{"title":"Jayson","subtitle":null,"description":"这里是一个要考研的大三程序狗的博客，喜欢跳舞，饶舌音乐，健身，在这里会记录自己的生活以及学习","author":"jayson","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2020-11-15T14:46:10.000Z","updated":"2020-11-23T14:37:50.116Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-15T14:49:34.000Z","updated":"2020-11-23T14:37:41.910Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"404","date":"2020-11-22T13:35:30.000Z","updated":"2020-11-22T13:37:39.399Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-11-22T13:35:01.000Z","updated":"2020-11-22T13:36:11.565Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-11-22T13:35:12.000Z","updated":"2020-11-22T13:36:46.270Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"动态规划","slug":"动态规划","date":"2020-11-23T16:45:26.000Z","updated":"2020-11-23T17:00:17.435Z","comments":true,"path":"2020/11/24/动态规划/","link":"","permalink":"http://example.com/2020/11/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划算法，一个感觉和递归很像的东西。 递归：自上到下，慢慢到底部，不会记录每个问题的结果，内存消耗相对小，但会冲股份计算相同的问题，耗时多。 动态规划：自下到上，会记录每一个问题的结果，内存消耗相对比较大，但不会计算相同的问题，时间消耗较小。 动态规划解决问题的特点 最优化：即一个问题的子问题的解也是最优的 无后效性：即一个状态与之后的决策无关，如找零钱问题amount[5]与amount[5+x]无关 有重叠子问题：子问题之间不是独立的，可能子问题之间存在子问题调用关系 tips：有重叠子问题不是必要条件，但这是动态规划算法相比其他算法的优势 动态规划算法步骤 创建一个存放保存子问题状态的空间 找到每个状态之间的之间的关系 返回需要求的值 找零钱问题123456789101112131415class Solution: def coinChange(self, coins, amount: int) -&gt; int: coins.sort() dp=&#123;&#125; dp[0]=0 for i in range(1,amount+1): dp[i]=amount+1 for i in range(1,amount+1): for j in coins: if i&gt;=j: dp[i]=min(dp[i],(dp[i-j]+1)) if dp[amount]&lt;amount: return dp[amount] else: return -1","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PCA降维以及图片重构","slug":"PCA降维以及图片重构","date":"2020-11-22T08:50:34.000Z","updated":"2020-11-22T12:57:18.856Z","comments":true,"path":"2020/11/22/PCA降维以及图片重构/","link":"","permalink":"http://example.com/2020/11/22/PCA%E9%99%8D%E7%BB%B4%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E9%87%8D%E6%9E%84/","excerpt":"","text":"数值计算中有一个大作业是关于PCA的降维以及重构的，这里就总结一下，感觉还是蛮实用的。 PCA概念PCA即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。 PCA思想 数据中的信息是分布不均匀的，有些地方数据多，有些地方数据少 所以将一些少的信息去掉，对于原始数据是没有很大影响的，即抓住主要矛盾，忽略次要矛盾 经过推导可以知道协方差矩阵的特征值代表了数据包含的信息量，所以可以取大的特征值，舍弃掉小的从而完成降维 PCA降维步骤 去平均值(即去中心化)，即每一位特征减去各自的平均值。 计算协方差矩阵$\\frac{1}{n}XX^T$ 求协方差矩阵$\\frac{1}{n}XX^T$的特征值和特征向量 对特征值从大到小排序，选择其中最大的k个。然后将其对应的k个特征向量分别作为行向量组成特征向量矩阵P。 将数据转换到k个特征向量构建的新空间中，即Y=PX。 图像重构将上面的Y乘上P.T加上去中心化减去的值得到重构的图像 即：$$reconstruction=Y*P’+meanvalue$$ 实验过程 读取训练集图像，每一个人脸图像以一个列向量的形式存在，所以需要将每个图像重构成列向量 12345678910for j=1:img_num %逐一读取图像 image_name = img_path_list(j).name;%图像名 img = imread(strcat(file_path,image_name)); img = imresize(img, 0.2, &#x27;nearest&#x27;); [irow,icol] = size(img);%得到图片大小 temp = reshape(img,irow*icol,1);%将二维图片转为一维向量 % 每张图片的信息做为V的一列 Q(:,j)=temp; imgTrain=[imgTrain,temp];end 读取完人脸数据后，将数据零均值化，即人脸向量减去平均值脸向量。然后求出这组数据的协方差矩阵的特征值向量和特征值向量,这些单位特征向量可以形成一个特征空间，然后把原图像向量向这个特征空间中投影，就可以得到特征脸 12345678910111213141516171819202122232425262728293031323334353637383940m = mean(imgTrain,2); % 平均图像/行平均Train_Number = size(imgTrain,2);%列数%计算机每一张图片到均值图像的方差A = []; for i = 1 : Train_Number%对每一列 temp = double(imgTrain(:,i))-m; %每一张图与均值的差异 A = [A temp]; %差矩阵end%得到A的协方差矩阵并转置得到LL = A&#x27;*A; % L是协方差矩阵C=A*A&#x27;的转置%得到特征值与特征向量[V,D] = eig(L); %对角线上的元素是L|C的特征值.V:以特征向量为列的满秩矩阵，D：特征值对角矩阵。即L*V = V*D.L_eig_vec = [];%特征值向量max=0;for i = 1 : size(V,2)%对每个特征向量 max=max+D(i,i);endsum=0;for i = size(V,2):-1:size(V,2)-2%对每个特征向量 L_eig_vec = [L_eig_vec V(:,i)]*0;%集中对应的特征向量 sum=sum+D(i,i);endfor i = size(V,2)-3:-1:size(V,2)-9%对每个特征向量 L_eig_vec = [L_eig_vec V(:,i)]*0.05;%集中对应的特征向量 sum=sum+D(i,i);endfor i = size(V,2)-10:-1:1%对每个特征向量 L_eig_vec = [L_eig_vec V(:,i)];%集中对应的特征向量 sum=sum+D(i,i); if(sum/max&gt;0.99) break; endendEigenfaces = A * L_eig_vec; % 计算机协方差矩阵C的特征向量， %得到降维了的特征,A为每一张图像与均值图像的差构成的矩阵，TrainProjectedImages = [];%映射图像for i = 1 : img_num%对于每一个训练特征 temp = Eigenfaces&#x27;*double(Q(:,i)); TrainProjectedImages = [TrainProjectedImages temp]; %得到 L_eig_vec;end 人脸重建 人脸重建实验的目的是为了测试特征脸所携带的人脸信息。由于特征值的大小代表了其所对应的特征向量所携带的信息量，通过将最大的一些特征值对应的特征向量叠加就可以获得原图像中的大部分信息量，也就是所谓的主成分。这里先将所有特征值按从大到小的顺序排列。通过叠加特征向量的方式，就可以得到一组对原人脸的逼近特征脸。而将特征值加起来，正是总的信息量，也可以求出重构误差。 人脸识别 人脸识别即给出一个待识别的在测试集中的图像，计算该图像与已经有的人脸即训练集中的人脸的距离，距离最小的则认为该图片的人脸。 123456789101112131415161718192021for i=1:Testcols mImgTestCur = TestProjectedImages(:,i); vDisMin = 9999999999999; vClassMin = -1; for j=1:Traincols mImgTrainCur = TrainProjectedImages(:,j); mDis = mImgTestCur-mImgTrainCur; mDis = mDis.^2; vDis = sqrt(sum(mDis)); if vDis&lt;vDisMin vDisMin = vDis; m=j; end end name1=img_path_list_train(m).name; name1 =name1(6:7);%取名字的6-7位置的字符 name2=img_path_list_test(i).name; name2 =name2(6:7); if name2==name1 count=count+1; end 未完待续…","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://example.com/tags/matlab/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"深度优先dfs","slug":"深度优先dfs","date":"2020-11-21T16:57:02.000Z","updated":"2020-11-22T06:47:25.444Z","comments":true,"path":"2020/11/22/深度优先dfs/","link":"","permalink":"http://example.com/2020/11/22/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88dfs/","excerpt":"","text":"d 之所以总结一下dfs，是因为刷python题目时候遇到一个题，单词搜索问题，类似于dfs思想的题目，不太会做，然后就总结一下 什么是DFSDepth First Search英文的缩写，翻译过来就是“深度优先搜索”。 深度优先遍历的主要思想就是：首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点；当没有未访问过的顶点时，则回到上一个顶点，继续试探访问别的顶点，直到所有的顶点都被访问。 沿着某条路径遍历直到末端，然后回溯，再沿着另一条进行同样的遍历，直到所有的顶点都被访问过为止。 即：不撞南墙不回头 算法过程 任意选择一个起点v，访问该顶点 沿深度方向，依次遍历未访问邻节点 tips：每次访问后都要将访问的vist[]变成1 递归伪代码12345678DFS(dep,、、、） &#x2F;&#x2F;dep代表目前DFS的深度&#123; if(找到解 || 走不下去)&#123; 、、、 &#x2F;&#x2F;在此处进行相应的操作 return ; &#125; 枚举下一种情况，DFS（dep+1,、、、）&#125; 非递归伪代码1234567891011121314151617bool visited[MAXNODE]; &#x2F;&#x2F;顶点的访问标识数组void DFSInit(Graph G)&#123; for(i&#x3D;0; i&lt;G.VertexNum; i++)&#123; visited[i] &#x3D; false; &#125;&#125;void DFS(Graph G,int v)&#123; &#x2F;&#x2F;v:顶点数组中的序号 Visit[v]; visited[v]&#x3D;true; w &#x3D; FirstAdj(G,v); &#x2F;&#x2F;返回：v的第一个邻接点，0表示无邻接点 while(w!&#x3D;0)&#123; if(!visited[w]&#123; DFS(G,w); &#x2F;&#x2F;参数传递w-&gt;v &#125; w &#x3D; NextAdj(G,v,w); &#x2F;&#x2F;返回：v的在邻接点w后的邻接点，0表示不存在 &#125;&#125; 其中一种DFS序列：DFS(G,v1) = (v1,v2,v3,v6,v5,v7,v4,v8,v9) 小结dfs即找准了一条路，如果满足判定成功条件或者失败条件（撞南墙）就返回上一个节点，再从这个节点继续找下一个，再撞再回溯。 单词搜索问题12345678910111213def dfs(self,i,j,cmap,word): if len(word)==0: #撞南墙 return True #撞南墙 elif i&gt;=len(cmap) or i&lt;0 or j&lt;0 or j&gt;=len(cmap[0]) or word[0]!=cmap[i][j]: return False temp=cmap[i][j] cmap[i][j]=&#x27;#&#x27; res =self.dfs(i+1,j,cmap,word[1:]) or self.dfs(i-1, j, cmap, word[1:]) or self.dfs(i, j+1, cmap, word[1:]) or self.dfs(i, j-1, cmap, word[1:]) #四种方向，其中有一种return True那这个节点即return True cmap[i][j]=temp return res 未完待续……………………………….","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"关于考研","slug":"postdsa","date":"2020-11-19T07:24:48.000Z","updated":"2020-11-19T07:43:46.425Z","comments":true,"path":"2020/11/19/postdsa/","link":"","permalink":"http://example.com/2020/11/19/postdsa/","excerpt":"","text":"d 现在是2020.11.19，距离大四毕业还有一年半的时间，还有半年我就要面临考研以及还是就业的选择，说实话，我现在是十分犹豫的。 我之所以想考研其实很大部分原因是因为感觉自己其实并没有准备好直接就进入职场经历那雨打风吹，而且读完研究生的薪资待遇确实是和本科生不同，可能是为了“钱途”吧，本来打算保不了研就直接从业的我产生了读研的想法。 关于之后这大半年其实计算机这门学科，只要你肯花时间去专研，琢磨，总结，深入，不停写码肯定可以收获不小的成功，哪怕不能做到最最最顶尖，但肯定是高于水准线之上很多的。我的想法是： 不断地刷题，刷leetcode，现在我把matrix上字节跳动的题目刷完就去刷leetcode了 总结，将知识点分类，或者觉得有用的东西弄到我的blog上，并且不断地美化自己的blog。 总结计网，计组，操作系统，计网的知识点到blog上，并且深入地做一些相关地研究或者实验去加深巩固，而且因为这学期是有计网2这个科目的，所以计网是放在第一优先级的 做一些实际的项目练手 考研科目英语100分 数学150分 政治100分 专业课：150分 数据结构45分，计算机组成原理45分，操作系统35分，计算机网络25分； 试卷题型结构：单项选择题，80分（40小题，每小题2分）；综合题，70分； 加油~愿韶华不负 ​ JAYSON","categories":[{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"}],"tags":[]},{"title":"链表in python","slug":"链表in-python","date":"2020-11-18T18:09:45.000Z","updated":"2020-11-18T18:31:49.555Z","comments":true,"path":"2020/11/19/链表in-python/","link":"","permalink":"http://example.com/2020/11/19/%E9%93%BE%E8%A1%A8in-python/","excerpt":"","text":"链表链表是python中特别重要且实用的数据结构，c++中的链表实现是分为指针和静态的，但因为python中没有指针结构，所以是只有静态的实现 链表节点的定义1234class ListNode: def __init__(self, x): self.val = x self.next = None 节点有两个内置变量，一个是val即储存的值。另一个是next，即指向的下一个节点。 链表的构建12345678910head= ListNode(5)for i in range(1,3): node = ListNode(i) cur = head.next if cur== None: head.next = node else: while cur.next != None: cur = cur.next cur.next = node 理解：头head是指向一个一般不动的，所以你要在头后面加数的话，得先建一个temp=head，然后改变temp在链表的位置使其指向最后一个数，再temp.next=node 链表求和123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 is None: return l2 elif l2 is None: return l1 head1=reverse(l1) head2=reverse(l2) head=None flag=0 while head1 is not None or head2 is not None: if head1 is None: node=ListNode(0) head1=node elif head2 is None: node = ListNode(0) head2 = node sum_num=head1.val+head2.val+flag if sum_num&gt;=10: flag=1 sum_num=sum_num%10 else: flag=0 temp=ListNode(sum_num) if head==None: head=temp else: cur=head while cur.next!=None: cur=cur.next cur.next=temp head1=head1.next head2=head2.next temp=head if flag==1: while temp.next!=None: temp=temp.next temp.next=ListNode(1) head=reverse(head) if head.val==0: head=head.next return head 判断链表是否有环1234567891011121314class Solution: def hasCycle(self, head: ListNode) -&gt; bool: slow_list = head fast_list = head while slow_list.next is not None and fast_list.next is not None: if fast_list.next.next is None: break slow_list=slow_list.next fast_list=fast_list.next.next if slow_list.val==fast_list.val: print(&quot;True&quot;,end=&#x27;&#x27;) return &#x27;&#x27; print(&quot;False&quot;,&#x27;&#x27;) return &#x27;&#x27;","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"基础数据结构list","slug":"lilst","date":"2020-11-16T09:32:51.000Z","updated":"2020-11-19T16:29:14.384Z","comments":true,"path":"2020/11/16/lilst/","link":"","permalink":"http://example.com/2020/11/16/lilst/","excerpt":"","text":"List数据类型是python中最为常用的数据类型，在这里总结一下对list的理解 列表数据类型是python中最为常用的数据类型，在这里总结一下对list的理解，以及常用的操作 List数据类型的理解列表类型与c++的数组和STL的vector十分像，且列表中的元素类型不是固定的，十分有意思。与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。 列表的创建list=[]//创建空列表 list = [‘physics’, ‘chemistry’, 1997, 2000] list=list(range()) 列表的基本操作添加元素在列表的最后一位添加元素 list.append(obj) 插入元素list.insert(index,obj) 移除元素移除列表中一个元素，并返回列表的值，默认是最后一位 list.pop([index=-1]) 列表取反list.reverse() 列表排序该方法没有返回值，但是会对列表的对象进行排序。 list.sort(cmp=None, key=None, reverse=False) 降序vowels.sort(reverse=True) 升序升序是默认的即：list.sort() vowels.sort(reverse=False) 链表切片切片操作确实还是蛮方便的，python中可以很轻易地实现对列表的切割 1list2=list1[a:b] 左闭右开即取a不取b [a:],[:b] #只取一边 其他列表操作 cmp(list1,list2) len(list) max(list) min(list) list(seq)//将元组转换为列表 list.count(obj)//统计某个元素在列表中出现的次数 list.index(obj)//从列表中找出某个值第一个匹配项的索引位置 list.remove(obj)//移除列表中某个值的第一个匹配项 列表的遍历 for i,j in list: for i in range(n): 以上是一些列表的基本操作，一般其实用不到特别复杂的操作，未完待续………","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"numpy","slug":"numpy","date":"2020-11-15T14:32:51.000Z","updated":"2020-11-15T15:00:58.945Z","comments":true,"path":"2020/11/15/numpy/","link":"","permalink":"http://example.com/2020/11/15/numpy/","excerpt":"","text":"[toc] 在数值计算中numpy特别使用，所以做一下关于numpy用法的记录 numpyimport numpy as np ARRAY的创建np.array()e.g. np.array([[1,1,1], ​ [[1,1,1]) np.zeros()#全零的矩阵 e.g. np.zeros([3,3]) np.ones()#全1的矩阵 e.g. np.ones([3,3]) np.empty()#空 e.g. np.empty([3,3]) np.full()e.g. array=np.full([3,3],6) #全是6的3*3矩阵 ARRAY的属性array.shape#几行几列 对于图像来说： ​ img.shape[0]：图像的垂直尺寸（高度） ​ img.shape[1]：图像的水平尺寸（宽度） ​ img.shape[2]：图像的通道数 而对于矩阵来说： ​ shape[0]：表示矩阵的行数 ​ shape[1]：表示矩阵的列数 array.size#大小 array.T#转置 array.real#虚数的实部 array.imag#实数的虚部 ARRAY的操作np.mean()np.mean(arr) #求所有值的均值 np.mean(arr,axis=0)#按列求均值 np.mean(arr,axis=1)#按行求均值 array.copy ()#复制拷贝 e.g. cc=array.copy() ！！！cc=array 这个是浅拷贝，cc改变array也会改变 array.reshape()array.reshape(2,8) #重塑形状，改变数组的行和列 array.resize()#resize()和reshape()的区别是前者数组自身会改变，后者不会 array.flatten#直接将数组拉平编程一维的 array.max()#最大值 np.matmul(a,b)矩阵乘法 np.tile()#将数组沿y或x扩大倍数 np.(a,(2,1))//第一个是y，第二个是x轴 ARRAY的索引切片array[1:3,1:3]#变成1，2行列的数组 #python索引是前面闭括号，后面开括号 键对索引array[[row1,row2],[col1,col2]] #一一对应 e.g. array[[0,2],[1,3]] np.nditer 迭代器e.g. for i in np.nditer(array): ​ print(i) ARRAY的拼接拆分拼接vstack#上下 np.vstack([array1,array2]) hstack#左右 np.hstack([array1,array2]) stack#维度 np.stack([array1,array2]) 拆分vsplithsplitsplit图像的读取库import matplotlib.pyplot as plt import matplotlib.image as mpimg import numpy as np 读取img=mpimg.imread(‘cat.jpg’) #此时 img 就已经是一个 np.array 了，可以对它进行任意处理 showplt.imshow(img) # 显示图片 plt.axis(‘off’) # 不显示坐标轴 plt.show()","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"first_article","slug":"first-article","date":"2020-10-25T16:15:37.000Z","updated":"2020-10-26T04:38:59.911Z","comments":true,"path":"2020/10/26/first-article/","link":"","permalink":"http://example.com/2020/10/26/first-article/","excerpt":"","text":"first第一个blog_text","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-10-25T15:43:49.321Z","updated":"2020-10-25T15:43:49.321Z","comments":true,"path":"2020/10/25/hello-world/","link":"","permalink":"http://example.com/2020/10/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"matlab","slug":"matlab","permalink":"http://example.com/tags/matlab/"}]}