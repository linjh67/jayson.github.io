{"meta":{"title":"Jayson","subtitle":null,"description":"这里是一个要考研的大三程序狗的博客，喜欢跳舞，饶舌音乐，健身，在这里会记录自己的生活以及学习","author":"jayson","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2020-11-15T14:46:10.000Z","updated":"2020-11-23T14:37:50.116Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-15T14:49:34.000Z","updated":"2020-11-23T14:37:41.910Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"404","date":"2020-11-22T13:35:30.000Z","updated":"2020-11-22T13:37:39.399Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-11-22T13:35:01.000Z","updated":"2020-11-22T13:36:11.565Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-11-22T13:35:12.000Z","updated":"2020-11-22T13:36:46.270Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"密码学复习","slug":"密码学复习","date":"2021-01-02T16:53:31.000Z","updated":"2021-01-03T16:38:31.113Z","comments":true,"path":"2021/01/03/密码学复习/","link":"","permalink":"http://example.com/2021/01/03/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"d 开始密码学的复习。 信息安全的基本要求 保密性 完整性 认证性 可用性 密码体制 $(P,C,K,E,D)$ P表示明文空间 C表示密文空间 K表示密钥空间 E：加密 D：解密 密码分析的方法 唯密文攻击 已知明文攻击 选择明文攻击 选择密文攻击 自适应选择密文攻击 密码体制的分类对密码体制的分类方法有多种，常用的分类方法有以下三种。 1、根据密码算法所用的密钥数量对称密码体制（Symmetric cipher，也称为单钥密码体制、对称密钥密码体制或常规密码体制）。如果一个密码系统，它的加密密钥和解密密钥相同，或者虽然不相同，但由其中的任意—个可以很容易地导出另外一个，那么该系统所采用的就是对称密码体制。非对称密码体制（Asymmetric cipher，也称为公开密钥密码体制、非对称密钥密码体制）。如果一个密码系统，其加密算法和解密算法分别用两个不同的密钥实现，并且由加密密钥不能推导出解密密钥，则该系统所采用的就是非对称密码体制。采用非对称密钥密码体制的每个用户都有一对选定的密钥。其中一个是可以公开的，称为公开密钥（Public key），简称公钥；另一个由用户自己秘密保存，称为私有密钥（Private key），简称私钥。 对称密码体制的主要优势是：加密、解密运算的处理速度块，效率高，算法安全性高。对称密码体制存在的局限性或不足：（1）对称密码算法的密钥分发过程复杂，所花代价高；（2）密钥管理困难；（3）保密通信系统的开放性差；（4）存在数字签名的困难性。 非对称密码体制的主要优势是：（1）密钥分配简单。（2）系统密钥量少，便于管理。（3）系统开放性好。（4）可以实现数字签名。非对称密码体制存在的局限性是加密、解密运算效率较低，处理速度较慢，同等安全强度下，非对称密码体制的密钥位数较多。 2、根据对明文信息的处理方式根据密码算法对明文信息的处理方式，可将对称密码体制分为：分组密码（Block cipher）序列密码（Stream cipher，也称为流密码）。 分组密码是将消息进行分组，一次处理一个数据块（分组）元素的输入，对每个输入块产生一个输出块。在用分组密码加密时，一个明文分组被当做一个整体来产生一个等长的密文分组输出。分组密码通常使用的分组大小是64比特或128比特。序列密码则是连续地处理输入元素，并随着处理过程的进行，一次产生一个元素的输出，在用序列密码加密时，一次加密一个比特或一个字节。 3、根据是否能进行可逆的加密变换根据密码算法是否能进行可逆的加密变换，可以将密码体制分为：单向函数密码体制双向变换密码体制 单向函数密码体制是一类特殊的密码体制，其性质是可以很容易地把明文转换成密文，但再把密文转换成正确的明文却是不可行的，有时甚至是不可能的。单向函数只适用于某种特殊的、不需要解密的应用场合，如用户口令的存储和信息的完整性保护与鉴别等。 双向变换密码体制是指能够进行可逆的加密、解密变换，绝大多数加密算法都属于这一类，它要求所使用的密码算法能够进行可逆的双向加解密变换，否则接收者就无法把密文还原成明文。 古典密码学移位密码基于模运算的，在$Z_{26}$空间内，进行移位，逆运算就是逆移位。 e_k(x)=(x+k)mod\\ 26\\\\ d_k(x)=(y-k)mod\\ 26代换密码明文中的每一个字符被替换成密文中的另一个字符。接收者对密文做反向替换就可以恢复出明文。 P=C=Z_{26},\\pi \\in K,\\\\ e_\\pi(x)=\\pi(x)\\\\ d_\\pi(x)=\\pi^{-1}(y)仿射密码要求 (a,26)=1因为要保证逆运算也是可以进行的，即可以完成解密 e_k(x)=(ax+b)mod\\ 26\\\\ d_k(x)=a^{-1}(y-b)mod \\ 26维吉尼亚密码是一种移位+多表代换的密钥 K=(k_1,k_2,...,k_m)\\\\ e_k(x_1,x_2,...,x_m)=(x_1+k_1,x_2+k_x,...,x_m+k_m)\\\\ d_k(y_1,y_2,...,y_m)=(y_1-k_1,y_2-k_x,...,y_m-k_m)希尔密码基于线性代数,密文是m*m,明文一次m个 e_k(x)=xK\\\\ d_k(X)=yK^{-1}流密码置换密码明文按m个分组，然后打乱顺序。 e_k(x_1,x_2,...,x_m)=(X_{\\pi(1)},X_{\\pi(2)},....X_{\\pi(m)})\\\\ d_k(y_1,y_2,...,y_m)=(y_{\\pi^{-1}(1)},X_{\\pi^{-1}(2)},....X_{\\pi^{-1}(m)})","categories":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"计网2复习","slug":"计网2复习","date":"2021-01-01T11:59:35.000Z","updated":"2021-01-01T17:21:22.020Z","comments":true,"path":"2021/01/01/计网2复习/","link":"","permalink":"http://example.com/2021/01/01/%E8%AE%A1%E7%BD%912%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"d IPv6的基础RFCIPv6协议的主要特征 IPv6协议具有巨大的地址空间 IPv6具有自动将IP地址分配给用户的功能 协议首部的简化和改进 IPv6对ICMP进行了改进 IPv6的分段只发生在源结点 IPSec是IPv6的重要组成部分 提供服务质量支持 IPv6协议对移动性提供内置的支持 IPv6路由简化 IPv6的首部IPv6的首部路由器转发IPv6分组的过程 IPv6扩展首部 逐跳选项扩展首部 从源结点到目的结点的路由上的每个结点，即每个转发分 组的网络结点（路由器）都检查逐跳选项中的信息。 选项类型，选项数据长度，选项数据 Pad1和PadN填充选项 超大有效荷载选项 路由器告警选项 路由扩展首部 用来指出IPv6分组在从源结点到目的结点的过程中，需 要经过的一个或多个网络中间结点（路由器）,即源路由 分段扩展首部 IPv6协议只允许源结点对分组进行分段，简化 了中间结点对分组的处理 身份认证扩展首部 用于实现数据的完整性和对分组来源的确认，完整 性保证了数据在传输过程中没有被篡改过，分组来 源的确认分组确实来自于源地址所标识的接口 封装安全荷载扩展首部 提供端到端的数据加密功能，以及无连接的完整性服务、 数据源认证、抗重发服务，还提供对通信流机密性的限制 目的选项扩展首部 携带只需要目的站点检验的可选信息，为中间结点 或目的结点指定分组的转发参数 IPv6协议与相邻层协议的关系 高层协议使用的一些规则和上层校验和计 算 IPv6伪首部格式：IPv6源地址、IPv6目的地址、上层协议包 长度、下一个首部字段 IPv6伪首部与上层协议构成校验和计算的内容 IPv6协议与底层网络协议 IPv6与链路层MTU (1).IPv6支持使用ICMPv6的分组过大报文的路径 MTU发现过程 (2).允许通过采用分段扩展首部的方法，传输长度 超过1280字节的IPv6数据包。 底层网络对IPv6协议的封装 IPv6CP的配置选项 接口标识符,IPv6压缩协议 若已经用IPv6CP选项协商了接口标识符，可以不 用进行IPv6无状态地址配置协议中的重复地址检测 若没有协商成功有效的接口标识符，则可以采用手 工配置接口标识符 IPv6与帧中继 IPv6地址结构IPv6地址长度是128位，包括16个字节 地址格式分类首选格式就是正常表示的形式，分为8个位段X:X:X:X:X:X:X:X 压缩表示格式 规定每个位段至少有一个数字，如“0000” 简写为“0” 多个连续位段0用两个冒号（双冒号）表示，简写为“::”，定双冒号在地址中只能出现一次 内嵌IPv4地址的IPv6地址格式的最低32位可以用于表示IPv4地址，X:X:X:X:X:X:d.d.d.d IPv4映射的IPv6地址 用于将IPV4节点表示为IPV6节点。允许IPV6 应用程序直接与IPV4应用程序通信 IPv6前缀IPv6地址被分成两个部分：子网前缀和接口标识符 e.g.4030:0:0:0:C9B4:FF12:48BC:1A27/60 IPv6地址分类单播、多播、任播和特殊地址 取消广播地址的原因同一网络链路上的大量广播意味着该链路上的每个 结点都必须处理所有广播，但是其中绝大部分结点 最终将忽略该广播。 IPv6对此的解决办法是使用一个“所有结点”多播 地址来替代那些必须使用广播的情况。 IPv6单播地址","categories":[{"name":"计网","slug":"计网","permalink":"http://example.com/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[{"name":"计网","slug":"计网","permalink":"http://example.com/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"黑客认识","slug":"黑客认识","date":"2020-12-29T17:00:34.000Z","updated":"2020-12-30T07:59:16.329Z","comments":true,"path":"2020/12/30/黑客认识/","link":"","permalink":"http://example.com/2020/12/30/%E9%BB%91%E5%AE%A2%E8%AE%A4%E8%AF%86/","excerpt":"","text":"d AP 网关 二级路由器????????????????? PPPOE得到动态ip地址 Qos路由器","categories":[{"name":"黑客","slug":"黑客","permalink":"http://example.com/categories/%E9%BB%91%E5%AE%A2/"}],"tags":[{"name":"黑客","slug":"黑客","permalink":"http://example.com/tags/%E9%BB%91%E5%AE%A2/"}]},{"title":"签名方案","slug":"签名方案","date":"2020-12-15T07:20:06.000Z","updated":"2020-12-15T16:49:03.733Z","comments":true,"path":"2020/12/15/签名方案/","link":"","permalink":"http://example.com/2020/12/15/%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%88/","excerpt":"","text":"d 签名方案说一下对签名方案的理解，原理就是使用发送方使用私钥加密，接收方使用公钥来解密，看看解密出来的结果是不是和发送方发过来的原文或者原文的摘要($hash$)，由于是私钥的原因则可以保证必定是出自发送方手里的。 ElGamal签名方案定义公钥: (p,\\alpha,\\beta)，其中\\beta=a^\\alpha私钥： (a)待签名数：$x$,随机数：$k$，签名函数： sig_k(x,k)=(y,\\delta)其中， y=\\alpha^kmod\\space p,\\delta=(x-ay)k^{-1}mod(p-1)验证函数: ver_k(x,(y,\\delta))=true\\leftrightarrow \\beta^yy^\\delta=\\alpha^x(mod \\space p)证明: \\beta^yy^\\delta=\\alpha^{ay}\\alpha^{k\\delta}\\\\\\delta=(x-ay)k^{-1}mode(p-1)\\\\所以,\\beta^yy^\\delta =\\alpha^x(mod\\space p)安全性Schnorr 签名方案 公钥:(p,q,\\alpha,\\beta),私钥:(a),\\beta=\\alpha^a其中， p\\approx2^{1024},q\\approx x^{160}，q|p-1\\\\ \\alpha是1模p的q次根，即:\\alpha=\\alpha_0^{(p-1)/q}mod\\space p,\\alpha_0是Z_p本原元签名: sig_k(x,k)=(y,\\delta)\\\\ y=h(x||\\alpha^kmod\\space p),\\delta=k+ay\\space mod\\space q验证函数： ver_k(x,(y,\\delta))=true\\leftrightarrow h(x||\\alpha^\\delta\\beta^{-y}mod\\space p)=y容易证明: \\alpha^\\delta\\beta^{-y}=\\alpha^k\\space mod\\space pDSADSA是结合了Schnorr的一种ElGmal的变形。 公钥:(p,q,\\alpha,\\beta),私钥:(a)其中 512\\leq|p|\\leq 1024,|p|mod\\space 64=0,q|p-1\\\\ \\alpha是1模p的q次根，即:\\alpha=\\alpha_0^{(p-1)/q}mod\\space p,\\alpha_0是Z_p本原元签名: sig_k(x,k)=(y,\\delta)\\\\ y=(\\alpha^kmod\\ p)mod\\ q,\\delta=(SHA-1(x)+ay)k^{-1}mod\\ q其中，$k$为随机数，$x$是待签名的,若$y=0|\\delta=0,k$要另取随机数 验证函数： ver_k(x,(y,\\delta))=true\\leftrightarrow (\\alpha^{e_1}\\beta^{e_2}mod\\ p)mod\\ q=y\\\\ e_1=SHA-1(x)\\delta^{-1}mod\\ q,e_2=y\\delta^{-1}mod\\ q证明： 设f(x)=SHA-1(x) \\\\即证:\\alpha^{e_1}\\beta^{e_2}=\\alpha^{k}\\\\ \\alpha^{e_1+ae_2}=\\alpha^k\\\\ \\alpha^{\\delta^{-1}(f(x)+ay)}=\\alpha^k\\\\ 由,\\delta =(f(x)+ay)k^{-1},QED","categories":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2020-12-12T15:37:07.000Z","updated":"2020-12-29T12:29:34.335Z","comments":true,"path":"2020/12/12/计算机网络/","link":"","permalink":"http://example.com/2020/12/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络 理解记忆，多思考确实哦 抓住重点 按五层，各层协议，网络设备 计算机网络概念，组成，功能和分类 计网的作用：将计算机系统(端系统)，通过通信设备（交换机，路由器）与线路连接起来，成为一个系统。 计算机网络的功能 数据通信 资源共享 硬件，软件，数据资源的共享 分布式处理 多台计算机承担一个工作任务的不同部分 提高可靠性 通过一些互补的操作，或者说是兜底的操作来使得这个系统更加可靠 负载均衡 计算机网络的组成 组成部分 硬件，软件，协议 工作方式 -边缘部分 （主机，端系统) -核心部分，为边缘部分提供服务的，就是路由器,网络那种啦 功能组成 -通信子网 (OSI下三层) -资源子网 (OSI上三层 ) 计算机网络的分类 按分布范围 广域网，城域网，局域网，个人区域网 按使用者 -公用网 -专用网 交换技术 -电路交换 -报文交换 -分组交换 按拓扑结构 总线型，星型，环型，网状型 按传输技术 广播式网络 ———公共通信 点对点网络 ——— 分组转发，路由选择 标准化工作及其相关组织标准化工作要有统一的标准才能实现互通：OSI，TCP/IP等 RFC 因特网标准的形式 RFC$\\rightarrow$因特网正式标准 因特网草案 建议标准———-成为RFC文档 草案标准 因特网标准 相关组织 ISO ———OSI模型 ITU IEEE IETF 性能指标速率又称比特率，数据传输率,即传送数据位数的速率 单位：b/s,kb/s,Mb/s,Gb/s,Tb/s 1Byte=8bit 1KB=1024B=1024*8b带宽最高数据率，是指在发送端能够传输的最高数据率，因为在链路中使用电磁波传输的 单位：b/s,kb/s,Mb/s,Gb/s,Tb/s 吞吐量单位时间内，通过某个网络（信道，接口）的数据量。 单位：b/s,kb/s,Mb/s,Gb/s,Tb/s 时延 传输时延 ：所有数据推到链路上 发送时延=\\frac{数据长度}{信道带宽（发送速率）} 传播时延：发生在信道外 传播时延=\\frac{信道长度}{电磁波在信道上的传播速率} 排队时延：等待时间 处理时延：检错，找出口 排队时延，处理时延一般是在路由器发生的 时延带宽积即某段链路有多少比特数据 时延带宽积=传播时延*带宽单位：$bit$ RTT从发送到收到确认的时间 利用率 信道利用率 信道利用率=\\frac{有数据通过时间}{全部时间} 网络利用率：信道利用率的加权平均 分层结构认识分层 服务：下层位上层提供服务 实体 协议(语法，语义，同步) 其实语法就是一串0/1的序列如果取分割，比如说前几个是用来干嘛的 语义就是具体这一段的怎么实现，比如001是a含义，010是b含义 接口（每两个层次间的） OSI参考模型上面四层是端到端的，下面三层是点到点的，有中间系统的存在。 应用层和用户交互产生网络流量的程序 典型 文件传输(FTP) 电子邮件(SMTP) 万维网(HTTP) 表示层处理两个通信系统中交换信息的表示方式 数据格式变换e.g.变成jpg格式图片 数据加密解密数据压缩和回复会话层向进程提供建立连接并在连接上有序地传输数据 会话之间相互独立 建立，管理，终止会话恢复通信使用校验点使得如果通信失效的话可以从校验点处继续回复通信 传输层负责主机中两个进程的通信，即端到端的通信。 传输单位：报文段或用户数据包 可靠传输,不可靠传输可靠传输TCP：建立连接，返回确认 差错控制对错误的信息进行纠错 流量控制控制发送方的速率，根据拥塞的返回来调节 复用分用多个用户使用一个IO资源 发送消息 时，我们称之为“复用”。 多个用户使用一个IO资源 接收消息 时，我们称之为 “分用” 。 操作系统的 多个进程（这里一个端口表示一个进程） 利用一个运输层协议（或者称为运输层接口）发送数据称为复用 同理，接收时叫做 分用。 网络层将分组从源端传到目的端，传输单位：数据报 路由选择走不同的路，根据路由表啥的来选择经过的路由 流量控制同传输层 差错控制奇偶校验码等来判断是否发生错误 拥塞控制全局性的，大量节点发生拥塞 主要协议IP,IPX,ICMP,IGNP,ARP,RARP,OSPF 数据链路层将网络层传下来的数据包组装成帧（传输单位） 成帧定义帧的开始和结束 差错控制帧错+位错 流量控制访问控制控制共享信道的访问 主要协议SDLC,HDLC,PPP,STP 物理层在物理媒体上实现比特流的透明传输 透明传输：给什么发生什么 定义接口特性定义传输模式单工：只能一个人 半双工 双工：两个人可以双向 定义传输速率比特同步比特编码主要协议Rj45,802.3 1.23TCP/IP网络接口层数据链路层+物理层 网际层网络层 传输层应用层应用层+表示层+会话层 5层参考模型应用层 传输层 网络层 数据链路层 物理层 第二章 物理层先不看 第三章 链路层研究思想：水平 基本概念 结点：主机，路由器 链路：结点之间的物理通道 数据链路：逻辑通道 帧：封装网络层数据报 封装成帧 帧同步：接收方可以区分出帧的起始和截止 MTU:最大传送单元（数据部分即ip数据包部分的长度最大值） 透明传输在链路层中所有比特组合都可以通过，因为可能逆传输帧的时候可能一个帧的头和尾的字节可能会在数据中产生重复之类的情况导致帧的识别的错误或者是接受时其他问题，所以我们要做的就是保证所有比特组合都可以通过 字符计数法 一错就后面都错 字符填充法 $SOH,EOT$ 添加了转义字符使得接收方把与$SOH,EOT$相同的字节按照数据接收，从而达到了透明传输 零比特传输发 首部和尾部的标识符一样，都是$01111110$,发送端时数据部分只要是连续五个一后面立即加零，就永远不可能有六个零的情况，在接受的时候再遇到五个一删零还原即可，从而实现了透明传输 违规编码法 高-高，低-低定界帧的起始和终止 差错控制差错由噪声引起。 位错：比特位出错 检错编码 奇偶校验码 奇校验：加了奇校验码1总数为奇数 偶校验：加了偶校验码1总数为偶数 $tips:$只能检出出来奇数个比特错误 循环冗余码CRC 纠错编码海明码发现双比特，纠正单比特 思想：每个效验码都是单单对应一个二进制的位，比如第一位错了，那就可以直到是数的第一位有1的错了。比如$5:0101$,最后一位为1……….然后全部位弄出来就知道….. 确定效验码位数r海明不等式： 2^r\\geq k+r+1r为冗余信息位，k为原始信息位 确定校验码和数据的位置效验码都是放在$2^j$位置上 求出校验码的值 检错并纠错所有要校验的位进行异或运算 帧错 丢失 重复 失序 流量控制就是根据接收方的接受能力调整发送方的发送数据的速度。 链路层：点对点（相邻结点），收不下不回复$ACK$ 传输层：端对端，发窗口通告 停止-等待协议其实就是窗口为1的滑动窗口 原理： 发送一个分组就停止发送，收到一个确认帧再发送下一个帧 差错情况 数据帧丢失或帧错误 超时计时器：大于平均$RTT$ 确认以及超时则重传机制 $tips:$保留副本，帧，确认帧编号！ 信道利用率： 信道利用率=(L/C)/T=\\frac{T_D}{T_D+RTT+T_A}信道吞吐率=信道利用率*发送方的发送速率 后退N步GBN协议 增加序号范围 缓存多个分组 发送窗口：允许发送的帧的序号窗口 发送完的窗口 已经发送待确认的 还不能发送的 接收窗口：允许接受帧的序号窗口 GBN发送方 检查窗口是否满了，未满就发送帧 累计确认，包括这个帧以及之前序号的都收到了 超时会发送所有发送但是未被确认的帧 GBN接收方 收到正确的n号帧，发送$ACK N$给发送方，并把帧中的数据部分交给上层 丢弃帧，为最近按序接受的帧发送$ACK$ 发送窗口长度 1\\leq W_T\\leq2^n-1接受窗口长度为1 选择重传协议因为后退N步协议一旦出错会把之前正确传输的也要重新传输所以就有了选择重传一说。 改变： 不再有累计确认，每次返回的都只是单独的ACK 接收方和发送方都只有滑动窗口的第一个完成了才能继续往前移动 发送方 上层调用 收到一个$ACK$ 超时事件 接收方 窗口内的帧来者不拒 其余情况 窗口大小 W_T=W_R=2^{n-1}介质访问控制静态划分信道又叫做信道划分介质访问控制，为什么叫做这个名字可能是因为就是已经提前就已经划分好了信道，固定了每个用户所占的带宽比例，不是动态的，所以有“信道划分”。 频分多路复用FDM时分多路复用TDM波分多路复用WDM码分多路复用CDM动态分配信道随机访问介质访问控制，所有用户随机发送信息，导致不协调！ ALOHA协议 不监听信道 #遇到冲突不知道，但收不到确认帧，即超时 不按时间槽发送 随机重发 #等待一个随机的事件 时隙ALOHA协议控制想发就发的随意性，把时间分成若干个相同的时间片，只能再下一个时间片开始时候再重传 CSMA协议先听再说！ CS:载波监听 MA:多点接入 思想：先监听信道再发送帧 信道空闲：发送完整帧 信道忙：推迟发送 1-坚持CSMA 一直监听，直到空闲 如果发送后有冲突，（一段时间没有收到确认帧），等待一个随机长的时间，重复 非坚持CSMA 忙则等待一个随机事件之后再进行监听 随机的重发延迟可以减少冲突发生的可能性 媒体使用率比较低 p-坚持CSMA 空闲则以p概率直接传输，不必等待，1-p概率等待到下一个时间槽再传输 忙则等待一个随机时间再进行监听 优点：结合了1，2，即减少了冲突，又减少了媒体的空闲 缺点：冲突后还是会坚持把数据帧发送完，造成了浪费 CSMA/CDCS:发送数据时和发送数据前都要检测是否有发送数据 MA:多点接入 CD:边发送边监听，适配器边发送数据边检测信道上信号电压电压的变化情况（半双工） 传播时延对载波监听的影响 截断二进制指数规避算法： 确定时间$2\\tau$ 定义k,k即为重传时间，$k=min[重传次数，10]$ 随机取$r\\in[0,1,2^k-1]$,重传所需要的时间就是$2r\\tau$ 若重传16次还是不成功，则认为网络太拥挤，抛弃此帧并报错 最小帧长： \\frac{帧长}{数据传输速率}\\geq 2\\tauCSMA/CA载波监听多点接入/冲突避免 CD适用于有线局域网，CA使用于无线局域网，因为无线局域网 无法做到360°全面检测 隐蔽站问题 A\\rightarrow B\\leftarrow C工作原理： 先检测是否空闲 空闲则发RTS，忙则等待 接收端收到RTS，响应CTS （可以解决隐蔽站问题，建立连接后不会处理别的请求，即接收不到CTS） 收到CTS后，开始发送数据帧，同时预约信道 CRC检验数据，正确则响应ACK 发送方收到ACK就进行下一个数据帧的发送，若没有则使用二进制退避算法来重发数据 轮询访问介质访问控制既要不产生冲突，又要发送时占全部带宽 轮询协议主结点轮流“邀请”从属结点发送数据。 问题： 轮询开销 等待延迟（靠后的主机可能会有等待延迟） 单点故障 （主结点出问题） 令牌传递协议 令牌：一个特殊的MAC控制帧 ，不含任何信息 将令牌帧变成一个数据帧，并且令牌的状态变成了忙状态 有令牌持有时间的限制 问题： 令牌开销 等待延迟 单点故障 应用于令牌环网（物理星型，逻辑环形拓扑），主要用于负载较大，通信量较大的网络中 局域网某一区域内的计算机组，使用广播信道 覆盖范围笑 数据传输速率高 延迟小，可靠性高 站点关系平等，共享传输信道 广播和组播 网络拓扑 星型拓扑 总线型拓扑 环形拓扑 树型拓扑 传输介质有线 无线 介质访问控制方法 CSMA/CD: 常用于总线型局域网，和树型网络 令牌总线 常用于总线型局域网，也用于树型网络 临牌环 常用于环形局域网 分类 以太网 IEEE802.3 令牌环网 FDDI网 ATM网 无线局域网 IEEE802.11 IEEE 802标准IEEE 802.3(以太网) IEEE 802.5（令牌环网） IEEE 802.8 (光纤技术FDDI网) IEEE 802.11(无线局域网) MAC子层和LLC子层IEEE 802将数据链路层分为逻辑链路子层LLC子层和介质访问控制MAC子层 LLC子层： 和网络层挨着，为网络层提供服务，负责识别网络层协议，并进行封装，以及处理问题 （无确认无连接，面向连接，待确认连接，高速传送） MAC子层：-【 和物理层挨着，帧方面的问题 以太网 便宜 实用，应用广 满足速率要求：10mb/s~10gb/s 两个标准： DIX Ethernet V2 IEEE 802.3 以太网只实现无差错接受，不实现可靠传输 逻辑上总线型，物理上星型 10BASE-T以太网适配器网卡，MAC地址，写在MAC帧中 以太网MAC帧高速以太网速率大于100MB/S的以太网 100BASE-T以太网 吉比特以太网 10吉比特 无线局域网IEEE 802.11 MAC帧头格式 分类 有固定基础设施的无线局域网 BSS：基本服务集 DS：分配系统（无线与有线的结合的实现） ESS:扩展的服务集（BSS+DS） 无固定基础设施无线局域网 无转发器，基站 广域网实用分组交换技术，跨越很大物理范围，将分布不同地区的局域网或计算机系统互连起来，达到资源共享的目的/ PPP协议点对点协议，只支持全双工。 要求: 简单 封装成帧 透明传输 与帧定界符一样的比特组合时候的数据处理方法：异步线路用字节填充，同步线路用比特填充 满足多种网络层协议 满足多种类型链路 差错检测 错就丢弃 检测连接状态 最大传输单元 网络层地址协商 数据压缩协商 不需要满足要求： 纠错 流量控制 序号 多点线路 组成部分 将ip数据报封装到串行链路的方法 链路控制协议LCP 建立并维护数据链路连接 网络控制协议NCP 帧格式帧定界符：7E 地址字段：FF HDLC协议高级数据链路控制协议，面向比特，可以实现透明传输（0比特插入法），全双工 站主站，从站，复合站 三种操作方式 正常响应方式 异步平衡方式 异步响应方式 帧格式帧定界符：01111110 ppp与HDLC区别 9数据链路层设备物理层扩展以太网 光纤调制器，解调器 集线器间连接起来形成主干集线器 冲突域，效率变低 链路层扩展以太网网桥对帧进行转发和过滤 透明网桥： 自学习 源路由网桥 发送帧时，把最佳路由信息放在帧的首部 方法：发送一个发现帧 以太网交换机（多接口网桥） 直通式交换机 查完目的地址立刻转发 延迟小，可靠性低，无法支持具有不同速率的端口的交换 存储转发式交换机 将帧放入高速缓存，检查是否正确 延迟高，可靠性高，支持具有不同速率的端口的交换 第四章网络层单位：数据报 功能： 路由选择与分组转发 异构网络互联 手机，电脑，wifi，4g的互联 拥塞控制 全局性的问题，整个网络负载过重 开环控制：静 闭环控制：动 数据交换方式通过交换设备（网桥，路由器，交换机）可以节省链路 电路交换e.g.电话网络 建立连接 通信 可以采用多路复用，独占特点 释放连接 优点： 通信时延小 有序传输 没有冲突（独占） 实时性强 缺点： 建立连接时间长 线路独占，使用效率低 灵活性差（一个交换设备出问题连接就崩溃了） 无差错控制能力 报文交换报文：源应用发送的信息整体 就是往目的主机去，然后中途的路径选择并没有固定，而是根据拥塞情况等来确定。 存储转发：会先把报文存储下来，链路空闲才会发 优点 无需建立连接 存储转发，动态分配线路 可靠性较高 利用率较高 多目标服务 缺点： 有存储转发时延 报文大小不定，需要网络结点有较大缓存空间 分组交换分组：把大的数据块分割成小的数据块 主要和报文交换的速度差别很大的原因是因为，报文交换的头是要等尾的，分组交换是不用等的，是并行的思想，而报文交换是串行的思想 优点： 无需建立连接 存车转发，动态分配线路 线路可靠性较高 线路利用率较高 相对报文交换，存储管理更容易 缺点： 存储转发时延 需要传输额外的信息量 乱序到达目的主机时，钥对分组排序重组 两种分组交换分类： 数据报方式 提供无连接服务 每个分组携带源和目的地址 路由器根据分组的目的地址转发分组 基于路由协议/算法构建转发表 检索转发表 每个分组独立选路 虚电路方式将数据报方式和电路交换方式的结合 建立连接 “呼叫请求”，每个分组携带虚电路号，而不是目的地址 数据传输 用分组作单位，路由表会根据分组的虚电路号来确定从哪个端口出去 释放连接 路由算法，路由协议最佳路由 静态路由算法 手工配置路由信息，手工配置下一跳等 动态路由算法 路由器彼此交换信息，按照路由算法优化出路由表项 链路状态路由算法（OSPF） 具有全局性，所有路由器都掌握了完整的拓扑以及链路费用信息，也就是所有路由器都知道全部信息 距离向量路由算法(RIP) 分散性，路由器之掌握了物理相连的状况 分层次的路由选择协议 因特网规模大 很多单位不想让外界知道自己的路由选择协议，但还是想加入因特网 \\downarrow自治系统AS（一组路由器，是自治的，外部是不知道内部路由选择协议的）（小团体） 路由选择协议： 内部网关协议IGP 一个AS内实用的，如：$RIP,OSPF$ 外部网关协议EGP AS之间实用的 如，$BGP$ RIP协议适用于比较小的网络，分布式的基于距离向量的路由选择协议，比较简单。 RIP协议要中要求的是路由器的转发表的是到达目的网络的最短距离。 距离：通常指跳数，RIP允许一条路由最多只有15个路由器，16表示网络不可达 仅和相邻路由器交换信息 交换的信息是自己的路由表 每30秒交换一次信息，并更新路由表。若3分钟没有收到邻居路由表，即当作邻居没了来更新信息 距离向量算法 修改相邻路由器发来的RIP报文中的所有表项 把从x中收到的RIP报文进行修改： 把”下一条“字段中的地址改为x，并把所有”距离“字段+1 对于每一项目进行处理，若R1没有该目的网络，就把项目填入R1路由表 若有，则看下一条路由器地址 若下一跳是x,则用收到的项目替换源路由表中的项目（因为要以新的信息为准） 若下一跳不是x，则根据长度是否小于原来的来判断是否更新 若180s没有收到相邻路由器x的RIP报文，则把x记作bbu可达路由器，即距离变成16 返回 RIP报文 RIP是应用层协议，使用UDP传送数据 一个RIP最多包括25个路由，如果超过那再用多几个RIP发送即可 RIP协议好消息传得快，坏消息传得慢，慢收敛过程 OSPF协议公开发表，使用了Dijkstra的最短路径算法，使用分布式的链路状态协议。 向所有路由器发送信息，洪范式，即传给相邻的，然后相邻的又传给相邻的，最后所有路由器都会收到 发送的信息是与本路由器相邻的所有路由器的链路状态（与什么路由器相邻，以及链路的代价/度量） 链路状态发生变化，才会发送信息 最后所有路由器能够建立一个链路状态数据库，即全网拓扑图 链路状态路由算法 OSPF的区域 OSPF分组 考纲：网络层协议 但也可以看成就是传输层中的数据被运输到网络层中进行封装。 BGP协议AS之间使用的协议 和谁交换与其他AS的邻站的BGP发言人交换信息 交换什么交换网络可达性的信息，即要到达某个网络索要经过的一系列AS，即一组路径向量 多久交换发生变化时更新有变化的部分 BGP发言人会根据所采用的策略从收到的路由信息中找到到达各AS较好的路由 BGP协议报文BGP协议报文是应用层协议，借用TCP传送。 BGP协议特点 BGP-4的四种报文 OPEN报文 实现与另一个BGP发言人连接的建立，并且对发送发进行认证 UPDATE报文 KEEPALIVE报文 周期性正式邻站的连通性，也作为OPEN的确认 NOTIFICATION报文 报告先前报文的差错，也用于关闭连接 三种路由协议的比较 IP数据报1.IP数据报格式 2.IP数据包分片以太网MTU是1500字节 分片使用到的数据包格式 标识：同一数据报的分片实用同一标识（16位） 标志：3位，只有两位有意义x_ _ 中间位DF（Don’t Fragment） DF=1:禁止分片 DF=0:允许分片 最低位MF(More Fragment) MF=1:后面还有分片 MF=0：后面没有分片 片偏移 13位，某片在原分组中的相对位置，以8B为单位 IPv4地址分类的IP地址32位的标识符，标识路由器，主机的接口（不同路由器的接口连接不同网络） IP地址：：{&lt;网络号&gt;，&lt;主机号&gt;} 使用点分十进制写IP地址，e.g. 128.1.1.2 A~E类IP地址 网络号不可以全0，A类减去127环回地址，主机号不可以全0，全1 特数IP地址 私有IP地址 路由器对目的地址是私有IP地址的数据报不转发，使用网络地址转换NAT解决 网络地址转换NAT原理： 在专用网到因特网的路由器上安装NAT软件，该路由器就被称为NAT路由器,它里面会至少有一个有效的外部全球IP地址，如果专用网里的主机要发送到因特网里的主机，那么发送的数据报中的源目的地址以及端口号都会变成NAT转换表中对应的可以在因特网中正常响应的ip地址，从而可以达到正常通信的目的。 子网划分子网划分就是把主机号里的一部分变成子网号 分类的IP地址的弱点： IP地址空间的利用率有时很低 两级IP地址不够灵活 子网掩码只要是网络号就是1，是主机号就是0 子网划分后，子网的部分也是1 子网掩码与IP地址逐位相与就是子网网络地址 所以分了子网掩码后，路由表中要有： 目的网络地址 目的网络子网掩码 下一跳地址 路由器转发找到那个目的ip地址的主机使用的方法是将目的网络地址的ip与它连的子网掩码相与，如果是与子网网络号相同那么久说明了目的主机在该子网中 无分类编址CIDR变长子网掩码 消除了传统的A类，B类，c类地址以及划分子网的概念 变成：网络前缀 主机号 CIDR记法：IP地址后面加上“/”，后面跟的是网络前缀的位数 e.g. 128.14.32.0/20 融合子网地址与子网，方便子网划分 地址块：128.14.32.0/20 128.14.32.0是地址块中的最小地址构成超网将多个子网聚合成为一个较大的子网 应用场景：路由器转发时候假如两个子网都是经过同一个端口的话可以将它们构成一个超网，可以解决数据冗余的问题 方法：将网络前缀缩短 e.g. 网络1:206.1.0.0/17 网络2:206.1.128.0/17 \\downarrow网络:206.1.0.0/16 最长前缀匹配查找路由表可能得到几个匹配结果，应该寻找具有最长网络前缀的路由，前缀越长，路由越具体 ARP协议发送数据过程在网络层封装ip地址，在数据链路层封装MAC地址 ARP高速缓存： （仅仅存储该局域网内的）IP地址与MAC地址的映射 假如没有对应IP地址的MAC地址映射，使用ARP协议： 先将IP3与子网掩码相与判断目的ip地址是不是与自己的IP地址在同一局域网， 假如在同一局域网： 广播ARP请求分组 单ARP响应分组 假如不在同一局域网： 下一跳地址变成了默认网关，而且是是知道默认网关的IP地址的，所以： 广播ARP请求分组 但ARP响应分组 传输到网关（路由器后） 假如还是不再同一局域网就重复上述步骤，假如到达同一局域网后就重复之前在同一局域网的情况 在实际网络的链路上传输数据帧时，最终必须使用MAC地址 DHCP协议获得ip地址 静态配置 ip地址，子网掩码，默认网关 动态配置 使用DHCP给移动的主机分配地址，分配完后如果走了就收回了 应用层，C/S，服务端与客户端使用广播方式交互，基于UDP 即插即用，地址重用，移动用户加入网络，再用地址续租 工作流程： 主机广播DHCP发现报文 寻找DHCP服务器 DHCP服务器广播DHCP提供报文 主机广播DHCP请求报文 使用广播报文的原因是因为可以告诉其他发送了DHCP提供报文的DHCP自己已经名花有主了 DHCP服务器广播DHCP确认报文 ICMP协议更加有效地转发IP数据报和提高交付成功的机会 ICMP协议支持主机或路由器： 差错报告$\\rightarrow$ 发送特定ICMP报文 ICMP差错报告报文 终点不可达报文 无法交付 源点抑制报文 拥塞丢数据 时间超过报文 TTL=0或数据报片在规定时间内无法收集完就全部丢弃并发送该报文 参数问题报文 首部字段有问题 改变路由报文 值得更好的路由，重定向报文 如何形成ICMP差错报文以及将其装入IP数据报 不发送ICMP差错报文的情况 ICMP询问报文 回送请求和回答报文 收到询问，然后向源主机或路由器发送 测试目的站是否可达以及了解其相关状态 时间戳请求和回答报文 请求主机或路由器回答母亲阿德日期和时间 掩码地址请求和回答报文 路由器询问和通告报文 ICMP的应用PING使用了ICMP回送请求和回答报文 Traceroute使用了ICMP时间超过差错报告报文 工作原理： 通过设置TTL从0-N,当TTL到0的时候就会返回一个时间超过差错报告报文，从而可以得到源到目的主机的距离 IPv6 改进了首部格式：快速处理/转发数据报 支持Qos 数据报格式分成两部分，基本首部和有效载荷，其中IPv4中可变部分相当于被移动到了IPv6的有效载荷的扩展首部中 IPv6支持即插即用，不需要DHCP协议 IPv6首部长度必须是8B的整数倍，IPv4是4B的整数倍 IPv6彻底移除了IPv4中的校验和字段，减少每一跳的处理时间 IPv6只能在主机处分片，IPv4可以在路由器和主机处分片 ICMPv6:附加报文类型”分组过大“ 支持资源的预分配 IPv6取消了协议字段，改成了下一个首部字段 与IPv4的区别 IPv6地址表示形式一般形式：冒号十六进制记法 e.g. 4BF5:AA12:0216:D1AD:12A5:A182:A2631:1534 压缩形式 基本地址类型 单播 一对一通信，可做源地址+目的地址 多播 一对多通信，可做目的地址 任播 一对多的一个通信，可做目的地址 双栈协议一台设备同时使用IPv4协议栈和IPv6协议栈 隧道技术就是把IPv6数据报放到IPv4的数据报中，从而建立了隧道 IP组播又叫多播 单播：点对点 广播：点对多点 组播：点对多点 组播与广播不同的是给的是需要特定数据的一组用户，并且组播数据发送这仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发。 IP组播地址属于多播组的设备将会被分配同一个组播IP地址（一群共同需求主机的标识） 组播地址范围：224.0.0.0~239.255.255.255（D类地址），一个D类地址表示一个组播组。只能用于分组的目的地址，源地址总是为单播地址 组播数据报应用UDP 不产生ICMP差错报文 并非所有D类地址用作为组播地址 硬件组播在局域网范围内。 组播MAC地址：01-00-5E打头，余下的十六进制是IP地址最后23位转换得来 收到组播数据报的主机还要再IP层利用软件进行过滤，把不是主机要接受的数据报丢弃，因为可能不是同一个组播的但是IP地址后23位相同导致了MAC地址相同的问题。 IGMP协议可以让一个组播路由器知道连接的局域网是否还有可以接受组播数据报的主机，是否有主机（的进程）参加或退出了某个组播组。 round 1： 某主机要加入组播组，想组播组的组播地址发送一个IGMP报文，声称自己要成为改组的成员，本地组播路由器接收到IGMP报文后，利用组播路由选择协议把这组成员关系发送给因特网上的其他组播路由器 round 2： 本地组播路由器会周期性探询（IGMP询问）本地局域网上的主机，以便知道这些主机是否还是组播组的成员 组播路由选择协议选路的过程，得到最佳路径。 找出以源主机为根节点的组播转发树，构造树可以避免在路由器之间兜圈子 使用算法： 基于链路状态的路由选择 基于距离-向量的路由选择 协议无关的组播（稀疏/密集） 移动IP相关术语移动结点 归属代理（本地代理） 外部代理（外地代理） 永久地址 转交地址：在外部网络中使用的临时地址 $A刚进入网络：$ 在外部代理等级获得一个转交地址，离开时注销 外地代理想本地代理等级转交地址 $B\\rightarrow A:$ 本地代理截获数据报 本地代理再封装数据报，新数据报的目的地址是转交地址，发给外部代理（隧道） 外部代理拆封数据报并发给A 网络层设备路由器 路由选择（控制部分） 分组转发 溢出造成分组丢失 三层设备的区别路由器：互联两个不同网络层协议的网段 网桥：可以互联两个物理层和链路层不同的网段 集线器：不能互联两个物理层不同的网段 路由表和路由转发 传输层只有主机才会有的层级，中间的网络设备是到不了传输层的。 功能： 提供进程与进程之间的逻辑通信 复用与分用 复用：使用同一个传输层协议进行传输 分用：把传来的报文段送给对应的进程 对收到的报文进行差错检测 TCP&amp;UDP TCP：面向连接，确认，流量控制，计时器，连接管理，时延大，适用于大文件 UDP：不需要连接，无确认，时延小，适用于小文件 端口：标识主机中的应用进程 端口号：只有本地意义，长度为16bit，65536各不同端口号 服务端使用端口号： 熟知端口号 0~1023，TCP/IP最重要的一些应用程序的端口号 等级端口号 1024~49151 客户端使用的端口号： 49151~65536 套接字$socket$=(主机IP地址，端口号) UDP协议 无连接，减少时延 不保证可靠交付 面向报文的，适合一次性传输少量数据的网络应用 对报文不合并也不拆分，保留整个报文 无拥塞控制，适合实时应用 丢一点是可以的，但没有延迟 UDP首部开销小，8B,TCP20B 首部格式 找不到对应的目的端口号，丢弃报文并发送ICMP“端口不可达”差错报告报文 UDP校验在UDP校验的时候会有一个伪首部，伪首部仅仅在校验的时候会出现。 17：封装UDP报文的IP数据报首部协议字段是17 步骤： TCP协议 面向连接 点对点的 可靠有序，不丢不重 全双工 面向字节流 首部格式 连接管理采用$C/S$模式 三次握手 客户端发送连接请求报文段，无应用层数据 SYN=1,seq=x 服务器返回确认报段，分配缓存和变量，五应用层数据 SYN=1,ACK=1,seq=y(随机),ack=x+1 客户端返回确认的确认，为TCP连接分配缓存和变量 SYN=0,ACK=1,seq=x+1,ack=y+1SYN洪范攻击： 攻击者给服务器发送大量请求，但是每个请求都不返回确认的确认，使得服务器不停地发送第二步地确认，占用大量缓存，可能导致死机 解决办法： SYN cookie 四次挥手终止连接，缓存和资源被释放 客户端发送连接释放报文段，停止发送数据，关闭TCP连接 FIN=1,seq=u 会送确认报文段，半关闭状态 ACK=1,seq=v,ack=u+1 服务器端发完数据，发出连接释放报文段，关闭TCP连接 FIN=1,ACK=1,seq=w,ack=u+1 客户端回送一个确认报文段，再等到时间等待计时器2MSL后，连接彻底关闭 ACK=1,seq=u+1,ack=w+1可靠传输保证接收方进程从缓存区中读出地字节流和发送方发出地字节流是完全相同的 校验 和UDP一样，增加伪首部 序号 一个字节占一个序号 序号字段：一个报文段的第一个字节的序号 确认 发送方缓存区收到了确认报文段或捎带确认，若确认字段为N，则N之前的都可以在缓存区间删除 重传 超时重长。 使用自适应算法，动态改变重传时间RTTs（加权平均往返时间） 冗余ACK（快速重传） 若收到3个冗余ACK，则认为丢失 流量控制使用滑动窗口机制。 发送端的窗口取决于接收方返回的确认报文段的窗口字段 设置了一个持续计时器，一方收到了对方的零窗口通知，就启动持续计时器。 若持续计时器值为0没收到通知就会发送一个零窗口探测报文段，接收方收到探测报文段就会给出现在的窗口值 若窗口值是0，那么发送方就会重置持续计时器 拥塞控制对资源需求的总和$&gt;$可用资源，全局性问题。 假设： 单方向传输，另一个方向只传送确认，无捎带确认 发送窗口=min{接收窗口rwnd,拥塞窗口cwnd}，这里假设rwnd足够大 慢开始和拥塞避免 ssthresh=\\frac{发生拥塞时候的cwnd}{2}快重传和快恢复 快恢复就是直接从新的$ssthreh$开始即可，不可恢复到1 应用层应用程序的通信提供服务。 应用层协议定义： 应用进程交换的报文类型，请求还是响应 各种报文类型的语法 字段的语义，即字段中的信息的含义 进程何时，如何发送报文，以及对报文进行响应的规则 应用层的功能： 文件传输，访问和管理 电子邮件 虚拟终端 查询服务和远程作业 网络应用模型C/S模型服务器：提供计算机服务的设备 永久提供服务 永久性的访问地址/域名 客户：请求计算机的主机 与服务器通信 间歇性接入网络 可能使用动态IP地址 不与其他客户机直接通信 P2P模型每个结点都可以当个服务器和客户。 任意节点都可以直接通信，可扩展性好，网络健壮性强。 DNS域名解析系统使用域名来替代ip地址来进行查询，访问网站。 功能：实现域名到ip地址的转换 顶级域名： 国家顶级域名 cn,us,uk 通用顶级域名 com,net,org,gov,int,aero,museum,travel 基础结构域名/反向域名 arpa 二级域名： 类别域名 ac,com,edu,gov,mil,net,org 行政区域名 bj,js 三级域名 四极域名 DNS服务器根域名服务器 顶级域名服务器 权限域名服务器 本地域名服务器：主机发出DNS查询，先发给本地域名服务器。 域名解析过程 递归查询 靠别人，请根域名服务器，…., 迭代查询 靠自己，自己本地域名服务器一个个去问… 使用高速缓存，动态更新 FTP文件传送协议提供不同种类主机系统之间的文件传输能力，基于C/S，使用TCP可靠传输。 FTP服务器：提供服务 FTP客户端：连接FTP服务器，与服务器进行传送文件的电脑 工作原理登录：ftp地址，用户名，密码，匿名登录 FTP服务器进程： 1个主进程 端口号：21 n个从属进程 电子邮件信息格式信封：abc@163.com 内容： 首部 主体 组成结构 用户代理 邮件服务器 邮件协议 SMTP,POP3 SMTP协议TCP，端口号：25 ,C/S 连接建立 邮件发送 连接释放 POP3协议TCP连接，端口号110，C/S 工作方式： 下载并保留 下载并删除 IMAP协议网际报文存取协议 基于万维网的电子邮件 万维网www，大规模的，联机式的资料空间，是无数个网络站点和网页的集合，C/S 统一资源定位符URL$\\rightarrow$ 资源 URL一般形式：&lt;协议&gt;://&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; e.g. http://www.pku.edu.cn URL不区分大小写 HTML协议超文本传输协议。 定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器 特点 无状态的 但是，万维网站点常常希望能够识别用户 \\downarrowCookie：存储在用户主机中的文本文件，记录一段时间内某用户的访问记录 采用TCP，但是HTTP协议本身是无连接的，交换HTTP报文之前不需要提前建立HTTP连接 持久连接 再次请求时候不需要再次建立TCP连接，连接不会断 流水线式 类似于后退N步…. 非流水线式 类似于停-等 非持久连接 报文结构分为请求报文，响应报文，HTTP报文是面向文本的，报文每一个字段都是一些ASCII码串 e.g.","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://example.com/tags/%E8%80%83%E7%A0%94/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"leetcode","slug":"leetcode","date":"2020-12-09T02:23:56.000Z","updated":"2020-12-23T07:02:22.466Z","comments":true,"path":"2020/12/09/leetcode/","link":"","permalink":"http://example.com/2020/12/09/leetcode/","excerpt":"","text":"开始leetcode的刷题了，总结leetcode并且做题解 Leetcode1. 两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 自己写的代码好像不太聪明的样子，复杂度达到$o(n^2)$….. 1234567891011class Solution: &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; def twoSum(self, nums, target: int): for i in range(len(nums)): for j in range(i+1,len(nums)): if nums[i]+nums[j]==target: return [i,j] 首尾递进复杂度是$o(nlogn)$ 123456789101112def twoSum(self, nums, target: int): index=sorted(range(len(nums)),key=lambda x:nums[x]) head=0 tail=len(nums)-1 while head!=tail: if nums[index[head]]+nums[index[tail]]&lt;target: head+=1 elif nums[index[head]]+nums[index[tail]]&gt;target: tail-=1 else: return [index[head],index[tail]] return [] 哈希表感觉也不咋样呀，用哈希表，和和首尾的差不多….. 12345678class Solution: def twoSum(self, nums, target: int): hashmap=&#123;&#125; for i in range(len(nums)): if target-nums[i] in hashmap: return [hashmap[target-nums[i]],i] hashmap[nums[i]]=i return [] 2.两数相加 链表问题，之前做过正序的更难，这个是逆序的，就是从个位加到后面，比较简单，解题思路就是假如那个地方是空的话就当作零来加，然后考虑进位。 还有种方法就是直接把两个当成长度相同的链表相加，在这之前先把另一个短的前面补零，这种我感觉快不了多少就3不弄上来了。 代码1234567891011121314151617181920212223242526272829303132333435class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = nextclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: index=0 sum_val=0 head=None while l1!=None or l2!=None: if l1 is None: sum_val=0+index+l2.val l2=l2.next elif l2 is None: sum_val=0+index+l1.val l1=l1.next else: sum_val=l1.val+index+l2.val l2=l2.next l1=l1.next index=int(sum_val/10) temp=ListNode(sum_val%10) if head is None: head=temp else: head_temp=head while head_temp.next is not None: head_temp=head_temp.next head_temp.next=temp if index==1: head_temp = head while head_temp.next is not None: head_temp = head_temp.next head_temp.next = ListNode(1) return head 7. 整数反转题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解题思路其实使用python感觉有点作弊，因为python本身就是可以支持大整数的，而它的题目是要考虑的，所以假如你得到的整数是溢出的你的整数就不能全部弄出来，而是再最后一步进行比较，看下图： 作弊代码123456789101112131415161718class Solution: def reverse(self, x: int) -&gt; int: if_postive=1 if x&lt;0: if_postive=0 x=-x sum_val=0 while x!=0: sum_val=sum_val*10+x%10 x=int(x/10) if if_postive==0: sum_val=-sum_val up_range=pow(2,31)-1 down_range=-up_range-1 if sum_val&gt;up_range or sum_val&lt;down_range: return 0 else: return sum_val 9.回文数解题思路我的思路是将其转换成字符串然后再求解，但这样好像消耗的空间太大了,但管他呢,空间大一点也没事把… 代码112345678910class Solution: def isPalindrome(self,x:int) -&gt; bool: x_str=str(x) i,j=0,len(x_str)-1 while j&gt;i: if x_str[i]!=x_str[j]: return False i+=1 j-=1 return True 代码2123class Solution: def isPalindrome(self,x:int) -&gt; bool: return str(x) == str(x)[::-1] 14.最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 解题思路 两两求最长公共前缀 字面意思，当发现公共前缀为空时就返回’’ 123456789101112131415161718192021class Solution: def longestCommonPrefix(self, strs) -&gt; str: if not strs: return &#x27;&#x27; a=strs[0] if not a: return &#x27;&#x27; for i in range(1,len(strs)): if not strs[i]: return &#x27;&#x27; a=self.two_str(a,strs[i]) if len(a)==0: return &#x27;&#x27; return str(a) def two_str(self,a,b): min_len=min(len(a), len(b)) for i in range(min_len): if a[i]!=b[i]: return a[:i] if i==min_len-1: return a[:min_len] 纵向比较 从0开始比较每个字符串的第i个,$i=0,1,2,3,..$字符是否都相同，当开始不相同的时候就返回前面相同的前缀 利用ascii码的特性 利用min()和max()，只用比较最大和最小的公共前缀即可， 举例abb， aba，abac，最大为abb，最小为aba。 123456789class Solution: def longestCommonPrefix(self, strs) -&gt; str: if not strs: return &#x27;&#x27; s1=min(strs) s2=max(strs) for i,x in enumerate(s1): if x!=s2[i]: return s2[:i] return s1 20.有效的括号题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 12输入: &quot;()&quot;输出: true 示例 2: 12输入: &quot;()[]&#123;&#125;&quot;输出: true 解题思路 使用栈，假如是左边的括号就推入栈，假如是右边的括号就把栈顶元素出栈来比较是不是一个可以匹配的括号 ascii码，左右括号要么相差1，要么相差2 代码123456789101112131415class Solution: def isValid(self, s: str) -&gt; bool: stack=[] for i in range(len(s)): if s[i]==&#x27;(&#x27; or s[i]==&#x27;[&#x27; or s[i]==&#x27;&#123;&#x27;: stack.append(s[i]) else: if len(stack)==0: return False a=ord(s[i])-ord(stack.pop()) if a!=1 and a!=2: return False if len(stack)!=0: return False return True 21.合并两个有序链表题目描述将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路我的方法还算快，就是一开始我就确定$l_2$作为被插入的链表，然后先看$l_1.val$是否小于$l_2.val$，如果小于就插入前面，大于就插入后面，这样操作完之后就可以保证后面的$l_1$的数都是可以插入在head后面的，然后就是假如$l_1.val$小于$l_2.next.val$，那么就让$l_2$的代理头指针head往后移一位，也就是只有$l_1$的值遇到了比它大的值或者$l_2$的代理头指针是空的时候才将$l_1$的值插入 代码123456789101112131415161718192021class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if not l1: return l2 if not l2: return l1 if l1.val&lt;l2.val: temp=l1 l1=l1.next temp.next=l2 l2=temp head=l2 while l1!=None: if head.next!=None and head.next.val&lt;l1.val: head=head.next else: temp=l1 l1=l1.next temp.next=head.next head.next=temp return l2 贪心算法376.摆动序列题目描述如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1: 123输入: [1,7,4,9,2,5]输出: 6 解释: 整个序列均为摆动序列。 示例 2: 123输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 解题思路贪心算法的思想，就是假如一个子数组一串都是上升(下降)的，那么其实值用取首尾就行了，[1,2,3,5]，取[1,5]即可，貌似应该也不用着啥动态优化吧，感觉用了还麻烦，其实题目思想倒是挺简单的说实话， 代码12345678910111213141516class Solution: def wiggleMaxLength(self, nums) -&gt; int: if len(nums)==1: return 1 count=len(nums) index=-1 for i in range(1,len(nums)): if nums[i]-nums[i-1]==0: count-=1 else: if index==-1: index=0 elif (nums[i]-nums[i-1])*(nums[i-1]-nums[index])&gt;0: count-=1 else: index=i-1 return count 别人的： 123456789101112131415class Solution: def wiggleMaxLength(self, nums: List[int]) -&gt; int: # c是用来记录前一个差值是下降还是上升的，默认0 n, c, res = len(nums), 0, 1 if n &lt; 2: return n for i in range(1, n): x = nums[i] - nums[i - 1] # 如果有差值才继续处理，相等直接就跳过不处理了 if x: # &lt;0代表有上升下降的交替，=0是初始情况的判断 if x * c &lt;= 0: res += 1 c = x return res 它的比我快，第一是它比较是否又交替的情况是用了个x，我是直接乘，第二有类情况是我讨论了index==-1,即初始的时候它的要求只要是与第一个数不等即可，它是$x * c &lt;= 0$来弄，因为它的初始$c$是0，。 栈144.二叉树的前序遍历解题思路一个是用递归的方法，一个是用迭代的方法，递归的话较为清晰，迭代的思想一开始我弄得很复杂，但其实很简单，只用把root-&gt;right一直压在栈的底部，那就可以达到最后调用的效果了。 迭代代码第一种是将root-&gt;一直压在栈底，第二种是和我一开始的想法差不多，一直左边入栈，如果左不下去了，就开始往右一次，然后继续看能不能左。但好像据说是说第一种方法并不是在模拟栈，而是先入先出的队列。 123456789101112131415class Solution: def preorderTraversal(self, root: TreeNode): if not root: return [] res=[] stack=[root] while stack: temp=stack.pop() res.append(temp.val) if temp.right: stack.append(temp.right) if temp.left: stack.append(temp.left) return reshead1 = TreeNode(5) 12345678910111213141516class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = list() if not root: return res stack = [] node = root while stack or node: while node: res.append(node.val) stack.append(node) node = node.left node = stack.pop() node = node.right return res 递归代码12345class Solution: def preorderTraversal(self, root: TreeNode): if not root: return [] return [root.val]+self.preorderTraversal(root.left)+self.preorderTraversal(root.right) 1234567891011class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: def preorder(root: TreeNode): if not root: return res.append(root.val) preorder(root.left) preorder(root.right) res = list() preorder(root) return res 94. 二叉树的中序遍历解题思路和前序的其实差不多，这个是在到达了左的极值，要出栈时把栈顶的节点的值加入res. 迭代代码123456789101112131415class Solution: def inorderTraversal(self, root: TreeNode): if root is None: return [] res=[] stack=[] node=root while stack or node: while node: stack.append(node) node=node.left node=stack.pop() res.append(node.val) node=node.right return res 递归代码12345class Solution: def inorderTraversal(self, root: TreeNode): if root is None: return [] return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) 145.二叉树的后序遍历解题思路递归代码12345class Solution: def postorderTraversal(self, root: TreeNode): if not root: return [] return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] 非递归代码1234567891011121314151617181920class Solution: def postorderTraversal(self, root: TreeNode): if root is None: return [] res=[] stack=[] prev=None while stack or root: while root: stack.append(root) root=root.left root=stack.pop() if not root.right or root.right==prev: res.append(root.val) prev=root root=None else: stack.append(root) root=root.right return res 402.移掉k位数字123456789101112class Solution(object): def removeKdigits(self, num, k): stack = [] remain = len(num) - k for digit in num: while k and stack and stack[-1] &gt; digit: stack.pop() k -= 1 stack.append(digit) return &#x27;&#x27;.join(stack[:remain]).lstrip(&#x27;0&#x27;) or &#x27;0&#x27;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]},{"title":"考研","slug":"考研","date":"2020-12-05T13:46:09.000Z","updated":"2020-12-08T05:29:53.391Z","comments":true,"path":"2020/12/05/考研/","link":"","permalink":"http://example.com/2020/12/05/%E8%80%83%E7%A0%94/","excerpt":"","text":"现在是2020.12.5，准备要开始考研的准备啦，因为我的基础其实没有很好，所以得好好地努力一把，加油！ 考研考研时间线12.5-12.20 总结考研的注意事项以及一些上岸人的心得与体会 总结各个学校的信息，确定要考的科目以及学校 买好408的部分教材 12.21-大三上学期期末结束开始复习计网，和数据结构，刷leetcode题目，总结到博客，这样考虑主要是因为我期末考试要考计网， 寒假-6月份第一轮复习结束，基础篇 7月份到九月份提高篇 十月份到十一月份冲刺篇 考研信息了解通道 研招网 目标院校的研究生官网 考研论坛考研论坛_考研人的精神家园！ (kaoyan.com) 学信网 中国考研网 小木虫 考研帮 考研学校分析 复旦大学 招262 数二，英二，408 华中科技大学 招120 数一，英二，834（数据结构，计网） 中山大学 招60 数二，英二，408 浙江大学 招149 数一，英一，408 武汉大学 招45 数二，英二，408 参考书目政治英语的复习问嘉琪吧。 政治：知识精讲+肖1000+肖八+肖四 英语：历年真题 单词：红宝书 恋练有词 新版恋词—题源报刊7000词 李剑词汇真经 模拟题 数学数一： 李永乐三件套。复习全书+数一真题+基础660题。 合工大五套卷 数二： 李永乐三件套。复习全书+数二真题+基础660题。 408： 王道和天勤的全套复习全书 王道出的真题解析，王道和天勤模拟题，大话数据结构 计算机组成原理，唐朔飞的教材，没答案的不做 王道8套模拟题 2. 1.教材：数据结构（严蔚敏）；计算机组成原理（唐朔飞）；操作系统（汤子瀛）；计算机网络（谢希仁） 2.辅导资料：王道四本单科书；南小文进阶600题；天勤高分笔记 3.模拟题：《408计算机专业基础综合》；王道最后八套模拟卷；王道计算机名校模拟题 4.真题：王道版408真题 最新复习plan英语英语每天花一个小时背单词(9点背到10点)","categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://example.com/tags/%E8%80%83%E7%A0%94/"}]},{"title":"数值微分","slug":"数值微分","date":"2020-12-05T02:19:43.000Z","updated":"2020-12-05T06:39:56.360Z","comments":true,"path":"2020/12/05/数值微分/","link":"","permalink":"http://example.com/2020/12/05/%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/","excerpt":"","text":"d 总结了数值积分，接下来就是数值微分了，好吧我再说废话。 两点前向差分公式 f(x+h)=f(x)+hf^{'}(x)+\\frac{h^2}{2}f^{''(c)} f^{'}(x)=\\frac{f(x+h)-f(x)}{h}-\\frac{h}{2}f^{''}(c) f^{'}(x)\\approx\\frac{f(x+h)-f(x)}{h}c是在区间$[x,x+h]$之间的,误差即$\\frac{h}{2}f^{‘’}(c)$ 三点中心差分公式 f(x+h)=f(x)+hf^{'}(x)+\\frac{h^2}{2}f^{''(x)}+\\frac{h^3}{6}f^{'''}(c1) f(x-h)=f(x)+hf^{'}(x)-\\frac{h^2}{2}f^{''(x)}-\\frac{h^3}{6}f^{'''}(c2) f^{'}(x)=\\frac{f(x+h)-f(x-h)}{2h}+\\frac{f^{'''}(c_h)}{6}h^2 f^{'}(x)\\approx\\frac{f(x+h)-f(x)}{h}二阶导 f^{''}(x)=\\frac{f(x+h)-2f(x)+f(x+h)}{h^2}+\\frac{h^2}{12}f^{(4)}(c)n阶到n+1阶一般中值定理存在$c\\in[a,b]$,使得 (a1+...+a_n)f(c)=a_1f(x_1)+...+a_nf(x_n)​","categories":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}]},{"title":"信号与系统第复习","slug":"信号与系统复习","date":"2020-12-03T11:00:29.000Z","updated":"2020-12-09T15:38:24.415Z","comments":true,"path":"2020/12/03/信号与系统复习/","link":"","permalink":"http://example.com/2020/12/03/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"开始复习信号与系统，按照章节来复习，记录重点，并且会总结题型。 Chapter 11. 信号分解任何信号都可以分解成一个偶信号和一个奇信号之和 x(t)=x_e(t)+x_o(t) x_e(t)=\\frac{1}{2}[x(t)+x(-t)] x_ot(t)=\\frac{1}{2}[x(t)-x(-t)]复指数信号1 连续的情况$x(t)=Ce^{at}$,C,a都是复数，这里不讨论C，a是实数的情况 x(t)=e^{jw_0t} a=jw_0 x(t)=e^{jw_0t}=cosw_ot+jsinw_0t一般情况下的正弦函数(不太懂？？？？)： x(t)=Acos(w_0t+\\phi)=\\frac{A}{2}e^{j\\phi}e^{jw_0t}+\\frac{A}{2}e^{-j\\phi}e^{-jw_0t}一般情况下复指数： x(t)=Ce^{at}, C=|C|e^{j\\theta},a=r+jw_0 x(t)=|C|e^{j\\theta}e^{rt}e^{jw_0t}2 离散的情况 x(n)=e^{jw_0n}=cosw_0t+jsinw_0t x(n)=C\\alpha ^n,\\space C=|C|e^{j\\theta},\\alpha=|\\alpha|e^{jw_0} x(n=)|C||\\alpha|^ne^{j(w_0n+\\theta)}=|C||\\alpha|^n*[cos(w_0n+\\theta)+jsin(w_0n+\\theta)]单位脉冲和单位阶跃序列1 离散情况 \\delta(n)= \\begin{cases} 1,n=0\\\\ 0,n\\neq0 \\end{cases} u(n)= \\begin{cases} 1,n\\geq0\\\\ 0,n0\\\\ 0,tn4.稳定性$x(n)$有界，$y(n)$有界 5.LTI系统的单位阶跃响应 Chapter 2还没整理完的 Chapter 3 周期信号的傅里叶级数表示傅里叶的作用 滤波 求解微分方程 频域中： $’1’:\\omega _0$ $’0’:cos(0t)$ 数学推导三角函数系 {0,1,sinx,cosx,sin2x,cos2x,...,sinnx,cosnx}三角函数的正交性:任取两个三角函数系不同的三角函数作积分值都为0 \\int_{-\\pi}^{\\pi}sinnx*cosmxdx=0 \\int_{-\\pi}^{\\pi}cosnx*cosmxdx=0,n\\neq m \\int_{-\\pi}^{\\pi}sinnx*cosmxdx=0,n\\neq m周期为$2\\pi$的函数展开为傅里叶级数 f(x)=f(x+2\\pi) f(x)=\\sum_0^\\infty a_ncosnx+\\sum_0^\\infty b_nsinnx,或 f(x)=\\frac{a_0}{2}+\\sum_1^\\infty a_ncosnx+\\sum_1^\\infty b_nsinnx等式两边积分，通过三角函数的正交性可以求得， a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)dx找$a_n$ 等式两边乘以$cosmx$,然后等式两边积分: a_n=\\frac{1}{\\pi}f(x)cosnxdx同理，找$b_n$ 等式两边乘以$sinmx$,然后等式两边积分: b_n=\\frac{1}{\\pi}f(x)sinnxdx周期为2L的函数傅里叶级数表示 f(t)=f(t+2L) x=\\frac{\\pi}{L}t,t=\\frac{L}{\\pi}x f(t)=f(\\frac{L}{\\pi}x)=g(x) g(x)=\\frac{a_0}{2}+\\sum_1^\\infty a_ncosnx+\\sum_1^\\infty b_nsinnx代入，得 表达式1： f(t)=\\frac{a_0}{2}+\\sum_1^\\infty a_ncos\\frac{n\\pi}{L}t+\\sum_1^\\infty b_nsin\\frac{n\\pi}{L}t a_0=\\frac{1}{L}\\int _{-L}^{L}f(t)dt a_n=\\frac{1}{L}\\int _{-L}^{L}f(t)cos\\frac{n\\pi}Ltdt b_n=\\frac{1}{L}\\int _{-L}^{L}f(t)sin\\frac{n\\pi}Ltdt表达式2： T=2L,\\omega=\\frac{\\pi}{L} f(t)=\\frac{a_0}{2}+\\sum_1^\\infty a_ncosnwt+\\sum_1^\\infty b_nsinnwt a_0=\\frac{2}{T}\\int_0^Tf(t)dt a_n=\\frac{2}{T}\\int_0^Tf(t)cosn\\omega dt b_n=\\frac{2}{T}\\int_0^Tf(t)sinn\\omega dt傅里叶级数的复数形式可以把$a_0,a_n,b_n$用用一种形式表达出来 欧拉公式 e^{i\\theta}=cos\\theta+isin\\theta cos\\theta=\\frac{1}{2}(e^{i\\theta}+e^{-i\\theta}) sin\\theta =-\\frac{1}{2i}(e^{i\\theta}-e^{-i\\theta})代入$f(t)$里, f(t)=\\frac{a_0}{2}+\\sum_{n=1}^\\infty \\frac{a_n-ib_n}{2}e^{in\\omega t}+\\sum_{n=1}^\\infty \\frac{a_n+ib_n}{2}e^{-in\\omega t} f(t)=\\sum_{n=0}^0\\frac{a_0}{2}e^{in\\omega t}+\\sum_{n=1}^\\infty \\frac{a_n-ib_n}{2}e^{in\\omega t}+\\sum_{n=-\\infty}^{-1} \\frac{a_{-n}+ib_{-n}}{2}e^{in\\omega t} f(t)=\\sum_\\infty ^\\infty C_ne^{in\\omega t}$C_n$代入并通过欧拉公式求得， C_n= \\begin{cases} \\frac{1}{T}\\int_0^T f(t)dt,n=0\\\\ \\frac{1}{T}\\int_0^T f(t)e^{-in\\omega t}dt,n=1,2,3...\\\\ \\frac{1}{T}\\int_0^T f(t)e^{-in\\omega t}dt,n=-1,-2,-3... \\end{cases}所以，最后: f(t)=f(t+T) f(t)=\\sum_{-\\infty} ^\\infty C_ne^{in\\omega_0 t},\\omega_0=\\frac{2\\pi}{T} C_n=\\frac{1}{T}\\int_0^T f(t)e^{-in\\omega_0 t}dt收敛性两组条件都是充分条件 平方可积条件： 若，$\\int_T|x(t)|^2dt&lt;\\infty$,则$a_k$必存在 Dirchlet条件： $x(t)$绝对可积，即$\\int_T|x(t)|dt&lt;\\infty$ 任何有限区间，只有有限个极值点，且极值为有限值 任何有限区间，只有有限个间断点，且间断点函数值有限 离散时间傅里叶级数$N$为周期 x(n)=\\sum_{k=}a_ke^{j\\frac{2\\pi}{N}kn} a_k=\\frac{1}{N}\\sum_{n=}x(n)e^{-j\\frac{2\\pi}{N}kn}傅里叶级数与LTI系统连续： x(t)=\\sum_{k=-\\infty} ^\\infty a_ke^{jk\\omega_0 t}\\rightarrow y(t)=\\sum_{k=-\\infty}^\\infty a_kH(jk\\omega_0)e^{jk\\omega_0t}频率响应： H(j\\omega)=\\int_{-\\infty}^\\infty h(t)e^{-j\\omega t}dt离散： x(n)=\\sum_{k=}a_ke^{j\\frac{2\\pi}{N}kn}\\rightarrow y(t)=\\sum_{k=-} a_kH(e^{j\\frac{2\\pi}{N}k})e^{j\\frac{2\\pi}{N}kn}频率响应： H(e^{j\\omega})=\\sum_{-\\infty}^{\\infty}h(n)e^{-j\\omega n}第四章连续时间傅里叶变换时域表达：$t\\rightarrow f(t)$ 频域表达:$n\\omega_0\\rightarrow C_n$ 非周期:$T\\rightarrow \\infty $ 离散到连续的变换 \\Delta \\omega=(n+1)\\omega_0-n\\omega_0=\\omega_0=\\frac{2\\pi}{T}T无穷，$\\Delta \\omega$趋近于零，所以频谱从离散到连续 推导 T\\rightarrow \\infty,\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}dt\\rightarrow \\int_{-\\infty}^\\infty dt n\\omega_0\\rightarrow \\omega \\frac{1}{T}=\\frac{\\Delta \\omega}{2\\pi} \\sum_{n=-\\infty}^{\\infty}\\Delta \\omega \\rightarrow \\int_{-\\infty}^\\infty d\\omega f(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(t)e^{-i\\omega t}dte^{i\\omega t}d\\omega傅里叶变换： F(\\omega)=\\int_{-\\infty}^\\infty f(t)e^{-i\\omega t}dt逆变换: f(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^\\infty F(\\omega)e^{i\\omega t}d\\omega收敛性和傅里叶级数的情况是一样的 平方可积条件： 若，$\\int_{-\\infty}^\\infty|x(t)|^2dt&lt;\\infty$,则$X(j\\omega)$必存在, 这表明能量有限的信号其傅里叶变换一定存在。 Dirchlet条件： $x(t)$绝对可积，即$\\int_{-\\infty}^{\\infty}|x(t)|dt&lt;\\infty$ 任何有限区间，只有有限个极值点，且极值为有限值 任何有限区间，只有有限个间断点，且间断点函数值有限 性质1.线性 ax(t)+by(t)=aX(j\\omega)+bY(j\\omega)2.时移 x(t)\\leftrightarrow X(j\\omega),则x(t-t0)\\leftrightarrow X(j\\omega)e^{j\\omega t_0}3.共轭以及共轭对称性 x(t)\\leftrightarrow X(j\\omega),则x^*(t)\\leftrightarrow X^*(-j\\omega),则4. 时域微分与积分5.时域和频域的尺度变换 x(t)\\leftrightarrow X(j\\omega),则x(at)\\leftrightarrow \\frac{1}{|a|}X(j\\frac{\\omega}{a})6.对偶性 x(t)\\leftrightarrow X(j\\omega),则X(jt)\\leftrightarrow 2\\pi x(-\\omega)7.Parseval定理 x(t)\\leftrightarrow X(j\\omega),则 \\int_{-\\infty}^\\infty |x(t)|^2dt=\\frac{1}{2\\pi}\\int_{-\\infty}^\\infty |X(j\\omega)|^2d\\omega卷积特性 x(t)\\leftrightarrow X(j\\omega),h(t)\\leftrightarrow H(j\\omega)则， x(t)*h(t)\\leftrightarrow X(j\\omega)H(j\\omega)第五章离散时间傅里叶变换 X(e^{j\\omega})=\\sum_{-\\infty}^\\infty x(n)e^{-j\\omega n} x(n)=\\frac{1}{2\\pi}{\\int}_{2\\pi}X(e^{j\\omega}e^{j\\omega n})d\\omega1.周期性 x(n)\\leftrightarrow X(e^{j\\omega}),则X(e^{j（\\omega +2\\pi)})=X(e^{j\\omega})2.线性3.时移与频移4. 时域反转5.共轭对成性6.差分与求和7. 时域内插8.频域微分9.Parseva第六章信号与系统的时域和频域特性傅里叶变换的模和相位 连续时间 X(j\\omega)=|X(j\\omega)|e^{j\\ang X(j\\omega)} 离散时间 X(e^{j\\omega})=|X(j\\omega)|e^{j\\ang X(e^{j\\omega)}}LTI系统频率响应中的模和相位LTI对输入信号所起的作用包括两个方面： 改变频率分量的幅度 改变频率分量的相对相位 Y(j\\omega)=X(j\\omega)H(j\\omega) |Y(j\\omega)|=|X(j\\omega)||H(j\\omega)| \\ang Y(j\\omega)=\\ang H(j\\omega)+\\ang X(j\\omega)线性与非线性相位若频率响应为：$H(j\\omega)=ke^{-j\\omega t_0}$,则： |H(j\\omega )|=k,\\ang H(j\\omega)=\\omega t_0可以看到相移是关于$\\omega$的线性函数，系统的输出就是输入的时移$y(x)=x(t-t_0)$. 离散的情况，则要求$H(e^{j\\omega})=e^{-j\\omega n_0}$中的$n_0$为整数，才能是线性的。 so,无失真传输条件 y(t)kx(t-t_0),y(n)=kx(n-n_0) 频域表征: H(j\\omega)=ke^{-j\\omega t_0},H(e^{j\\omega})=ke^{-j\\omega n_0} 时域表征： h(t)=k\\delta (t-t_0),h(n)=k\\delta (n-n_0) |H(j\\omega )|=k,\\ang H(j\\omega)=\\omega t_0 群时延对非线性相位系统，定义群时延： \\tau (\\omega)=-\\frac{d}{d\\omega}\\ang H(j\\omega)群时延代表了在一个很窄的频带或很少的一组频率上信号所受到的有效公共延时。 第七章采样将离散信号无失真地转化为连续信号 冲激串采样 p(t)=\\sum_{n=-\\infty}^\\infty \\delta (t-nT) x_p(t)=x(t)p(t)=\\sum_{n=-\\infty}^\\infty x(t)\\delta (t-nT)T为采样周期,$\\omega_s=\\frac{2\\pi}{T}$称为采样频率， p(t)\\leftrightarrow P(j\\omega)=\\frac{2\\pi}{T}\\sum_{-\\infty}^{\\infty}\\delta(\\omega-\\frac{2\\pi}{T}k)求卷积： X_p(j\\omega)=\\frac{1}{2\\pi}X(j\\omega)*P(j\\omega) =\\frac{1}{2\\pi}X(j\\omega)*\\frac{2\\pi}{T}\\sum_{-\\infty}^{\\infty}\\delta(\\omega-k\\omega_s) =\\frac{1}{T}\\sum_{k=-\\infty}^{\\infty}X(j(\\omega-\\omega_s),\\omega_s=\\frac{2\\pi}{T}采样定理设$x(t)$是某一个带限信号，在$|\\omega|&gt;\\omega_M$时$X(j\\omega)=0$。如果$\\omega_s&gt;2\\omega_M$，其中，$\\omega_s=\\frac{2\\pi}{T}$，那么$x(t)$就唯一地由样本 $x(nT),n=0,±1,±2,⋯$所确定。 零阶保持采样现实中一般是很难实现冲激信号的，一般是对某一时刻的$x(t)$保持样本值，直到下一个样本值被采样。这就称为零阶保持. 内插重建1.理想内插2.零阶保持内插3.一阶保持内插欠采样与频谱混叠如果不满足采样定理，如$\\omega_s&lt;2\\omega_M$，在进行周期延拓的时候就会发生频谱混叠的情况 第八章通信系统傅里叶在通信中确实很有用 第九章拉普拉斯变换傅里叶变换有一个局限性就是必须得满足狄利赫里条件，特别是绝对科技条件，比如$f(x)=x^2$就不能使用傅里叶变换，所以科学家就想到了乘以一个快速衰减的函数，所以趋于$\\infty$时候原函数衰减到零，满足绝对可积。 拉普拉斯变换 t(t)=H(s)e^{st},H(s)=\\int_{-\\infty}^\\infty h(t)e^{-st}dt$s=j\\omega$时,即是连续时间傅里叶变换。扩展到整个复数域，$s=j\\omega+\\sigma$时，$x(t)$的双边拉式变换： X(s)=\\int_{-\\infty}^\\infty x(t)e^{-st}dt\\\\=\\int_{-\\infty}^\\infty [x(t)e^{-\\sigma t}]e^{-j\\omega t}dt=F(x(t)e^{-\\sigma t})所以$x(t)$的拉式变换就是$x(t)e^{-\\sigma t}$的傅里叶变换 傅里叶反变化： x(t)e^{-\\sigma t}=\\frac{1}{2\\pi}\\int_{-\\infty}^\\infty X(s)e^{j\\omega t}d\\omega x(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^\\infty X(s)e^{(\\sigma +j\\omega)t}d\\omega用$ds$代替$d\\omega$,$\\sigma$为常数，所以有拉普拉斯反变换: x(t)=\\frac{1}{2\\pi j}\\int_{-\\infty+\\sigma}^{\\infty +\\sigma} X(s)e^{st}ds拉普拉斯正变换： X(s)=\\int_{-\\infty}^\\infty x(t)e^{-st}ds收敛域(ROC)$e^{-\\sigma t}$是一个衰减因子，$\\sigma$的取值不同，则衰减的速度也不同。如果衰减过慢，那么$x(t)e^{-\\sigma t}$不收敛,因此定义收敛域为使得$X(s)$存在的$s$的区域，记为ROC,也是拉氏变换的存在条件。 $\\sigma$取值不同，衰减的方向也不同： $\\sigma&gt;0,x(t)$是右边信号(只有$t&gt;0$时候有值)，则存在$\\sigma_1,$对$\\forall \\sigma&gt;\\sigma_1,\\lim_{t\\rightarrow\\infty}x(t)e^{-\\sigma t}=0$,此时$ROC:\\sigma&gt;\\sigma_1$ $\\sigma0$时候有值)，则存在$\\sigma_2,$对$\\forall \\sigma&gt;\\sigma_2,\\lim_{t\\rightarrow\\infty}x(t)e^{-\\sigma t}=0$,此时$ROC:\\sigma&gt;\\sigma_2$ 自然数ee代表了连续，对于一个单位状态量的变化率是固定值(%100)的系统，e代表在一个单位时间内，连续的翻倍增长所能达到的极限值. e=\\lim_{n\\rightarrow \\infty}(1+\\frac{1.00}{n})^n e^x=\\lim_{n\\rightarrow \\infty}((1+\\frac{1.00}{n/x})^{n/x})^x=\\lim_{n\\rightarrow \\infty}((1+\\frac{x}{n})^n由上面的分析可知，对于一个单位状态量的变化率是固定值的系统，其状态可以用自然常数的指数函数来表示。 欧拉恒等式 e^{ix}=\\lim_{n\\rightarrow \\infty}(1+\\frac{ix}{n})^n在n趋近于无穷的时候，$e^{ix}$其实就是一个单位圆 所以自然而然的有： e^{ix}=cosx+isinx欧拉恒等式: e^{i\\pi}+1=0","categories":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://example.com/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://example.com/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"demo1","slug":"demo1","date":"2020-12-01T17:33:35.000Z","updated":"2020-12-01T17:34:42.982Z","comments":true,"path":"2020/12/02/demo1/","link":"","permalink":"http://example.com/2020/12/02/demo1/","excerpt":"","text":"(FREE) Old Town 世俗蒙蔽了眼睛 无法分辨真假 有人不懂 有人确实在装疯卖傻 何必再去相信 那些他人的言语 bitch 太多 我不是傻白甜别来占我便宜 我嫌弃的不是你 是这个社会 所谓的君子太多 让我不禁撤退 那些表面一套 背后一套的人让我作呕 我要化身为魔 我偏要和社会作对； 招数太多 没有包袱 脸皮都不要 耍着阴招 达到新高 穿肠的毒药 那些虚假的fake 得到了虚假的位置 看不清楚几两几斤 尽然觉得自己对 bitch 是否还能看得见 bitch 不然继续犯着贱 bitch 还在对我放着电~ mother fxxker,早就看得厌 马戏团 跳梁小丑 笑着 跳着舞 太一般 弱的loser 叫了 笑着哭 太极端 专研 停止 不止三年 形势 早就被拉开差距 实力悬殊 射手专注 化身艾希 点了战争热诚 实力过人 提起加特林 嘟嘟嘟嘟嘟 地不停地输出 刺痛你的神经让你疼 成王败寇 成为夺冠热门 J to the N 开始代表时代的声音 从地狱到天堂 180的高度 J to the N 开始代表时代的声音 从地狱到天堂 十八般的招数 bitch 是否还能看得见 bitch 不然继续在这里犯着贱 bitch 还在对我放着电 mother fxxker,早就看得厌","categories":[{"name":"饶舌","slug":"饶舌","permalink":"http://example.com/categories/%E9%A5%B6%E8%88%8C/"}],"tags":[{"name":"饶舌","slug":"饶舌","permalink":"http://example.com/tags/%E9%A5%B6%E8%88%8C/"}]},{"title":"离散对数问题","slug":"离散对数问题","date":"2020-12-01T17:01:34.000Z","updated":"2020-12-07T08:21:01.784Z","comments":true,"path":"2020/12/02/离散对数问题/","link":"","permalink":"http://example.com/2020/12/02/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"离散对数问题可以表达成一下形式： \\beta\\in,找出唯一指数a，0\\leq a\\leq n-1,使得\\alpha ^a=\\betaShanks算法Pollard $\\rho$算法Pohlig-Hellman算法","categories":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"数值积分","slug":"数值积分","date":"2020-11-30T15:54:33.000Z","updated":"2020-12-01T14:23:19.153Z","comments":true,"path":"2020/11/30/数值积分/","link":"","permalink":"http://example.com/2020/11/30/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/","excerpt":"","text":"数值积分当遇到无法解析求解的定积分，可以使用数值积分来计算 思想从公式： I=\\int_a^bf(x)dx=(b-a)f(\\xi)开始，可以看到$f(\\xi)$平均高度是个关键点，从这里着手，提供一种近似算法将其取代 定义取适当的节点$x_k$并用$f(x_k)$的加权平均值座作为$f(\\xi)$的近似值 I=\\int_a^bf(x)dx\\approx \\sum_{k=0}^nA_kf(x_k)=I_n$x_k$：求积节点 $A_k$：求积系数，$A_k$仅与$X_k$有关 $R(f)=I-I_n$ ：求积余项 m次代数精度精度准确即是$\\int_a^bf(x)dx$ 与 $\\sum_{k=0}^nA_kf(x_k)$相等，代数精度越高，求积公式则越好 对所有次数不超过m的多项式都精确成立 至少对一个m+1次多项式不精确成立 充要条件求积公式具有m次代数精度充要条件是该求积公式： 对$x^k(k=0,1,2,…,m)$精确成立 对$x^{m+1}$不精确成立 插值型积分插值型积分也就是能够确定$A_k$的值，实际上应该是任意一种不同类型的数值积分都是可以确定$A_k$的值的，$A_k$的值将在下面给出推导： 先取n+1个在$[a,b]$的节点$x_i$,则可以求得$f(x)$的拉格朗日插值多项式 L_n(X)=\\sum_{k=0}^nf(x_k)l_k(x) ,f(x)\\approx L_n(x) I=\\int_a^bf(x)dx=\\int_a^b\\sum_{k=0}^nf(x_k)l_k(x)=\\sum_{k=0}^nA_kf(x_k) 所以有， A_k=\\int_a^bl_k(x)还有一些$R(f)$,插值型求积公式充要条件，收敛性，稳定性就不总结了，应该不会考 牛顿-科特斯公式即是插值型积分，特别的就是取的$x_k$的值是取将$[a,b]$划为n等分取的,特斯拉系数是比较好求的多项式积分，并且与[a,b]无关，再者有个特斯拉系数表表格 h=\\frac{b-a}{n},x_k=a+kh A_k=\\int_a^bl_k(x)dx=\\int_a^b\\prod_{j\\neq k}\\frac{x-x_j}{x_k-x_j}dx,(k=0,1...,n)科特斯系数$C_k^{(n)}$: C_k^{(n)}=\\frac{(-1)^{n-k}}{nk!(n-k)!}\\int_0^n \\prod_{j\\neq k}^n(t-j)dt,(k=0,1...,n) A_k=(b-a)C_k^{(n)} I=\\sum_{k=0}^nA_kf(x_k) 复合Simpson公式 h=(b-a)/n \\int_a^bf(x)dx=\\frac{h}{6}[f(a)+4*\\sum_{k=0}^{n-1}f(x_k+\\frac{h}{2})+2*\\sum_{k=1}^{n-1}f(x_k)+f(b)]","categories":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}]},{"title":"插值","slug":"插值","date":"2020-11-28T17:30:30.000Z","updated":"2020-12-01T09:44:18.095Z","comments":true,"path":"2020/11/29/插值/","link":"","permalink":"http://example.com/2020/11/29/%E6%8F%92%E5%80%BC/","excerpt":"","text":"数值计算学习中有学到插值，总结一下插值，和拟合的区别是拟合是找到总体上来说离给出的已知点最近的曲线，插值则是求得的曲线是满足都经过已知点的，就很牛逼。 插值一些定义以及性质 插值函数g(x): g(x_i)=f(x_i),i=0,1,....,n 插值节点：上面的{$x_i$} 定理：n+1个$x_i$不相同节点的n次插值多项式存在且唯一 拉格朗日插值理解朗日朗日插值它的插值多项式在非它的插值节点$x_i$的$l(x_j)$都取0 缺点：节点变化的时候拉格朗日插值需要重新构造 插值函数 g(x)=f(x_0)l_0(x)+f(x_1)l_1(x)+...+f(x_n)l_n(x)​ #$l_i(x)$是次数不超过n次的多项式 对于g(x_i),l_i(x)=1，l_j(x)=0,j\\neq iLagrange基函数： l_i(x)=\\frac{(x-x_0)(x-x_{i-1})(x-x_{i+1})(x-x_n)}{(x_i-x_0)(x_i-x_{i-1})(x_i-x_{i+1})(x_i-x_n)}Lagrange插值： L_n(x)=f(x_0)l_0(x)+f(x_1)l_1(x)+...+f(x_n)l)n(x)例子 分段拉格朗日插值分段线性拉格朗日插值差不多就是两两相邻的节点形成一个拉格朗日插值，x在哪个区间就使用哪个拉格朗日插值 L^{(k)}(x)=y_kl_k(x)+y_{k+1}l_{k+1}(x),k=0,1,2...n-1 =y_k\\frac{x-x_{k+1}}{x_k-x_{k+1}}+y_{k+1}\\frac{x-x_{k}}{x_{x+1}-x_{k}}L(x)=$L^{(k)}(x)$ ， 当$x_k\\leqslant x&lt;x_{k+1}$ 内插：插在里面 ……………… 外插：$x^*\\notin[x_0,x_n]$ 分段二次插值","categories":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}]},{"title":"python下函数与图像的显示","slug":"python下函数与图像的显示","date":"2020-11-27T16:57:10.000Z","updated":"2020-12-01T09:46:46.404Z","comments":true,"path":"2020/11/28/python下函数与图像的显示/","link":"","permalink":"http://example.com/2020/11/28/python%E4%B8%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%98%BE%E7%A4%BA/","excerpt":"","text":"数值计算里为了显示函数的图像，总结一下python里相关的知识。 调库matplotlib.pyplot和MATLAB很相似，之中各种状态通过函数调用保存。 123import numpy as npimport matplotlib.pyplot as pltfrom pylab import * np.arange()np.arange(a,b,step) #step是步长 函数返回一个有终点和起点的固定步长的排列，如[1,2,3,4,5]，起点是1，终点是6，步长为1。 plt.plot()plt.plot(x,y,format_string,**kwargs) 函数用来确定x,y，以及图像的一些颜色之类的特征 参数 说明 x X轴数据，列表或数组，可选 y Y轴数据，列表或数组 format_string 控制曲线的格式字符串，可选 **kwargs 第二组或更多(x,y,format_string)，可画多条曲线 format_string 由颜色字符、风格字符、标记字符组成 颜色字符 &#39;b&#39; 蓝色 &#39;m&#39; 洋红色 magenta &#39;g&#39; 绿色 &#39;y&#39; 黄色 &#39;r&#39; 红色 &#39;k&#39; 黑色 &#39;w&#39; 白色 &#39;c&#39; 青绿色 cyan &#39;#008000&#39; RGB某颜色 &#39;0.8&#39; 灰度值字符串 多条曲线不指定颜色时，会自动选择不同颜色 风格字符 &#39;‐&#39; 实线 &#39;‐‐&#39; 破折线 &#39;‐.&#39; 点划线 &#39;:&#39; 虚线 &#39;&#39; &#39; &#39; 无线条 标记字符 &#39;.&#39; 点标记 &#39;,&#39; 像素标记(极小点) &#39;o&#39; 实心圈标记 &#39;v&#39; 倒三角标记 &#39;^&#39; 上三角标记 &#39;&gt;&#39; 右三角标记 &#39;0&lt;&#39; 左三角标记…等等 plt.show()显示图像 plt.figure()要显示的图像的名字 e.g. 1plt.figure(&quot;my_pic&quot;) plt.subplot()把多张图显示到一个显示界面上。 plt.subplot(row,col,code)#生成row行，col列，code是编号 12345678910111213t=np.arange(0.0,2.0,0.1)s=np.sin(t*np.pi)plt.subplot(2,2,1) #要生成两行两列，这是第一个图plt.subplot(&#x27;行&#x27;,&#x27;列&#x27;,&#x27;编号&#x27;)plt.plot(t,s,&#x27;b--&#x27;)plt.ylabel(&#x27;y1&#x27;)plt.subplot(2,2,2) #两行两列,这是第二个图plt.plot(2*t,s,&#x27;r--&#x27;)plt.ylabel(&#x27;y2&#x27;)plt.subplot(2,2,3)#两行两列,这是第三个图plt.plot(3*t,s,&#x27;m--&#x27;)plt.subplot(2,2,4)#两行两列,这是第四个图plt.plot(4*t,s,&#x27;k--&#x27;)plt.show() y=cos(x)图像1234567x=np.arange(-5.0,5.0,0.01)y1=np.cos(x)print(y1.shape[0])plt.figure(1)plt.subplot(211)plt.plot(x,y1,&#x27;b&#x27;)plt.show()","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"拟合","slug":"拟合","date":"2020-11-26T09:09:47.000Z","updated":"2020-12-01T09:47:27.542Z","comments":true,"path":"2020/11/26/拟合/","link":"","permalink":"http://example.com/2020/11/26/%E6%8B%9F%E5%90%88/","excerpt":"","text":"拟合，插值，逼近是数学分析的三大基础工具，在这里总结一下拟合 拟合：已知点列，整体靠近它们 插值：已知点列并且完全经过点列 逼近：已知曲线，或者点列，通过逼近使得构造的函数无限靠近它们 拟合拟合定义 最小二乘问题最小二乘即f(X)-g(X)的范数是2-范数，这种问题就是最小二乘问题。 所以，即找g(x)使得 ||f(x)-g(x)||_2=\\sqrt{\\sum_{i=0}^n(f(x_i)-g(x_i))^2}取到最小值，记为评价函数$L(a_1,a_2…..a_n)$ 欲取得评价函数最小值，则要对每个变量$a_i$的偏导等于零，即： \\frac{\\partial L}{\\partial a_i}=0 ,i\\in(1,n) 线性拟合 f(x)=ax+b 低次多项式拟合 f(x)=ax^3+bx^2+cx+d 指数拟合 f(x)=e^{ax+b} \\downarrow \\ln{f(x)}=ax+b将$\\ln{f(x)}$记为y,则变成了线性拟合y=ax+b 线性角度的最小二乘从微积分的视角来看，最小二乘法相当于求解约等方程组，那么最小二乘法的线性代数视角又是什么呢？ 先来看向量的投影： b,p,e 是3个向量，其中p是b 在平面上的投影， e是b和p 的误差向量，e=b-p 。平面可以看作二维向量张成的向量空间，p 在该空间上。将向量投影到向量空间有什么意义呢？这要从方程 Ax=b 说起。 小明根据测量结果得到了一个方程组，并将它进一步化简为矩阵的形式： 对于小明的数据来说， Ax=b无解，实际上大多数这种类型的方程都无解。A的列空间的含义是方程组有解时b 的取值空间，当b 不在 A的列空间时，方程无解。具体来说，当A 是行数大于列数的长方矩阵时，意味着方程组中的方程数大于未知数的个数，此时肯定无解。 虽然方程无解，但我们还是希望能够运算下去，这就需要换个思路——不追求可解，转而寻找最能接近问题的解。对于无解方程Ax=b 来说，Ax 总是在列空间上（因为列空间本来就是由 Ax确定的，和b 无关），而 b就不一定了，所以需要微调 ，将p 调整至列空间中最接近它的一个，此时Ax=b 变成了： p就是 b在 A的列空间上的投影， x上加一个小帽子表示x 的估计值。当然，因为方程无解，所以本来也不可能有 Ax=b。此时问题转换为寻找最好的估计值 ，使它尽可能满足原方程： 在上图中，A的秩是2，平面表示A的列空间，平面上的向量有无数个，其中最接近b 的当然是b 在平面上的投影，因为只有在这时 b-p 才能产生模最小的误差向量。 如何求得估计值呢？ 在小明的测量数据中，A的列空间是一个超平面，A的两个列向量都在这个超平面上，b和p 的误差向量e垂直于超平面，因此e也垂直于超平面上的所有向量，这意味着e 和 A的两个列向量的点积为0。 将二者归纳为一个矩阵方程： 矩阵方程已经去掉了关于 的信息，通过该方程可进一步求得估计值： 这就是最终结果了，它是由矩阵方程推导而来的，所以这个结果叫做“正规方程”。 还有一种更简单的方式可以得到正规方程。Ax=b无解的原因是因为 A 是一个长方矩阵，只要在等式两侧同时乘以 AT，就可以把长方矩阵转换成方阵，进而求解。 多项式的非线性拟合y=cosx求出A，b,然后套公式就行了： x=(A^TA)^{-1}A^Tb12345678910111213def least_squres(n): b=np.zeros(9)#测试数据为8 for i in range(9): b[i]=cos(-pi+(6/8)*i) A=np.zeros([9,n+1]) #n次方,则有n+1个c_i for i in range(9): for j in range(n+1): A[i][j]=(-pi+(6/8)*i)**j #x=np.zeros(n+1) x=np.dot(np.linalg.inv((np.dot(A.T,A))),np.dot(A.T,b)) print(x) return x 一共有5个曲线，蓝色和绿色分别是n=2和n=3的时候，红色，黑色，白色分别是n=4,n=6,y=cosx的时候，可以看到n=2,3时候与y=cosx有一定差别,而用n=4,6的多项式拟合y=cosx与原图基本是重合的。","categories":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}]},{"title":"排序算法","slug":"排序算法","date":"2020-11-24T12:53:16.000Z","updated":"2020-12-01T09:47:23.053Z","comments":true,"path":"2020/11/24/排序算法/","link":"","permalink":"http://example.com/2020/11/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"复习数据结构，然后总结一下数据结构的排序算法，并再用python全都实现一次。 排序比较排序冒泡排序冒泡排序是最基本的排序算法，比较相邻的元素，将大（小）的放到后面。每一躺循环，将最大（最小）的交换到最后面。 算法流程 第一躺循环，从arr[0]到arr[N-1]，两两比较，若arr[x]&gt;arr[x+1]，则进行交换，从而使得最后在arr[N-1]的是最大的数 下一趟循环，则变成从arr[0]到arr[N-2] 重复直到完成最后一趟循环即arr[0]到arr[1]的比较 算法评价一共进行了N-1次循环，确定了N-1次要确定的最大数 稳定，平均时间复杂度为$o(n^2)$ 算法代码1234567891011def Bubble_Sort(arr): length=len(arr) j=length-1 for i in range(length-1): for x in range(j): if arr[x]&gt;arr[x+1]: temp=arr[x] arr[x]=arr[x+1] arr[x+1]=temp j-=1 return arr 插入排序顾名思义，插入排序(Insertion Sort)就是将一个元素插入到已经排序好的序列中，这里是arr[x]插入到已经排序好的(arr[0]~arr[x-1])中 算法流程 index左边是有序的，右边是待插入的，index是从1开始，N-1结束 两种选择： 从右往左一个个两两交换，直到遇到比arr[index]小的数停止 把arr[index]用temp保存，找到要插入的位置insert_index，即是最后一个比temp大的数的位置，将arr[insert_index]到arr[index-1]全都往后移一位，然后再插入 算法代码 第一种 12345678def Insertion_Sort(arr): for i in range(1,len(arr)): for j in range(i,0,-1): if arr[j]&lt;arr[j-1]: temp=arr[j] arr[j]=arr[j-1] arr[j-1]=temp return arr 123456789def Insertion_Sort(arr): for i in range(1,len(arr)): temp=arr[i] j=i-1 while j&gt;=0 and arr[j]&gt;temp: arr[j+1]=arr[j] j=j-1 arr[j+1]=temp return arr 选择排序选择排序就是每次在待选择的序列里选择一个最小的到最前面，感觉比前面两种垃圾一点。 算法流程 找到列表中最小的元素将其与列表第一个元素交换 其次，将剩下的待排序的元素中找到最小的元素将其与第二个元素交换 重复，完成N-1躺排序 时间复杂度：$o(n^2)$ 算法代码1234567891011def Selection_Sort(arr): for i in range(len(arr)): min_index=i for j in range(i+1,len(arr)): if arr[j]&lt;arr[min_index]: min_index=j if min_index!=i: temp=arr[i] arr[i]=arr[min_index] arr[min_index]=temp return arr 快速排序快速排序有动态规划，递归的思想，将大的慢慢地分成小的，即分治法，然后还有挖坑填数。 时间复杂度 最好：o(nlogn) 最坏：$o(n^2)$ 算法流程 把数组的第一个数当作基准线 通过一躺排序将数据分成两部分，左边是比基准线pivot小的，有部分是比基准线大的。（这里用的是挖坑法）下面介绍 递归，左边在分成两部分，右边也分成两部分一直递归成一个数就是完成了排序 挖坑法（如下例子）表格中红色的字体为需要填的坑，绿色的字体为已经移动过的数据。 1.刚开始，i 和 j 分别指向数组头和数组尾，即 i = 0，j = 9，基准数取第一个数，即index = array[i] = array[0] = 23。 此时，array[0]的值已经存在了index，因此array[0]的位置就好像被挖了个坑，可以填充一个数。 因此，我们从位置 j 开始向左寻找比index小的数，当 j = 8 时，符合条件，于是我们将array[8]的值填到array[0] ，即将9填入array[0]，并将 i 向右移动一个位置，即 i++。从位置 j 向左寻找比index小的数，并在寻找到后填入坑中，用代码表示如下。 123456while (i &lt; j &amp;&amp; array[j] &gt;= index) &#123; // 向左寻找第一个小于index的数 j--;&#125;if (i &lt; j) &#123; array[i++] = array[j]; // 将array[j]填入array[i]，并将i向右移动&#125; 此时，array数组如下图。 2.因为array[0]的坑被array[8]填了，于是array[8]的位置又成了一个新的坑。此时我们从位置 i 开始向右寻找比index大的数，当 i = 2 时符合条件，于是我们将array[2]的值填到array[8] ，即将37填入array[8]，并将 j 向左移动一个位置，即 j—。从位置 i 向右寻找比index大的数，并在寻找到后填入坑中，用代码表示如下（跟上面相似）。 123456while (i &lt; j &amp;&amp; array[i] &lt; index) &#123;// 向右寻找第一个大于index的数 i++;&#125;if (i &lt; j) &#123; array[j--] = array[i]; // 将array[i]填入array[j]，并将j向左移动&#125; 此时，array数组如下图。 3.同样的，array[8]的坑被array[2]填了，于是array[2]的位置又成了一个新的坑。此时我们从位置 j 开始向左寻找比index小的数，当 j = 5 时符合条件，于是我们将array[5]的值填到array[2] ，即将21填入array[2]，并将 i 向右移动一个位置，即 i++，此时array数组如下图。 4.同样的，array[2]的坑被array[5]填了，于是array[5]的位置又成了一个新的坑。此时我们从位置 i 开始向右寻找比index大的数，当 i = 3 时符合条件，于是我们将array[3]的值填到array[5] ，即将89填入array[5]，并将 j 向左移动一个位置，即 j—，此时array数组如下图。 5.同样的，array[5]的坑被array[3]填了，于是array[3]的位置又成了一个新的坑。此时我们从位置 j 开始向左寻找比index小的数，当 j = 4 时符合条件，于是我们将array[4]的值填到array[3] ，即将2填入array[3]，并将 i 向右移动一个位置，即 i++，此时array数组如下图。 6.此时，我们发现 i = j，结束遍历，并将index填入array[4]，即将23填入array[4]，此时array数组如下图。此时，array[4]左边的数据全比array[4]小，而array[4]右边的数据全比array[4]大。 7.接下去，我们只需要对array[4]两边的数据分别在进行上面的操作即可（分治法），如下图。 分治的代码可以写成如下： 12quickSort(array, low, i - 1); // 递归调用，分治quickSort(array, i + 1, high); // 递归调用，分治 算法代码12345678910111213141516171819202122232425262728def Quick_Sort(arr,first,last): if first&gt;=last: return arr pivot=arr[first] count=0 #count为0的时候就是从右往左选比temp小的数 #count为1的时候就是从左往右选比temp大的数 i=first j=last-1 while i!=j: if count==0: if arr[j]&lt;pivot: arr[i]=arr[j] count=1 i+=1 else: j-=1 else: if arr[i]&gt;=pivot: arr[j]=arr[i] count=0 j-=1 else: i+=1 arr[i]=pivot Quick_Sort(arr,first,i) Quick_Sort(arr,i+1,last) return arr 归并排序归并排序的思想是分治法，将一个待排序的数组分成两半，不断地分直到数组中只有一个数，然后再返回去，从底向上的去排序 算法流程 将一个数组一切为二分成两半 递归地切，结束条件是数组长度为1 底层的向上开始排序，方法为新建一个空数组temp，因为对于每一个数组切的一个组来说，它的两个子组其实都是已经排好序的了，所以只要比较两个子组的第一个数，一直将小的那个压进temp里即可 例子 当我们要排序这样一个数组的时候，归并排序法首先将这个数组分成一半。如图： 然后想办法把左边的数组给排序，右边的数组给排序，之后呢再将它们归并起来。当然了当我们对左边的数组和右边的素组进行排序的时候，再分别将左边的数组和右边的数组分成一半，然后对每一个部分先排序，再归并。如图： 对于上面的每一个部分呢，我们依然是先将他们分半，再归并，如图： 分到一定细度的时候，每一个部分就只有一个元素了，那么我们此时不用排序，对他们进行一次简单的归并就好了。如图： 归并到上一个层级之后继续归并，归并到更高的层级，如图： 直至最后归并完成。 只不过现在计算机中时间的效率要比空间的效率重要的多。无论是内存也好还是硬盘也好可以存储的数据越来越多，所以设计一个算法，时间复杂度是要优先考虑的。整体来讲我们要使用三个索引来在数组内进行追踪。 \\** 蓝色的箭头表示最终选择的位置，而红色的箭头表示两个数组当前要比较的元素，比如当前是2与1比较，1比2小，所以1放到蓝色的箭头中，**蓝色的箭头后移，1的箭头后移。 然后2与4比较，2比4小那么2到蓝色的箭头中，蓝色箭头后移，2后移，继续比较……. \\** 算法代码123456789101112131415161718ef Merge_Sort(arr): if len(arr)==1: return arr else: a=Merge_Sort(arr[:int(len(arr)/2)]) b=Merge_Sort(arr[int(len(arr)/2):]) temp=[] while len(a)!=0 or len(b)!=0: if len(a)==0: temp.append(b.pop(0)) elif len(b)==0: temp.append(a.pop(0)) else: if a[0]&lt;b[0]: temp.append(a.pop(0)) else: temp.append(b.pop(0)) return temp 希尔排序希尔排序可以说是高级版的插入排序，还挺牛逼的，原理大概就是先将待排序的数组大致做一个排序，然后这个数组宏观上看起来就是顺序的，所以最后到最细致的插入排序的时候其实基本就不用怎么交换。 算法流程 确定分组，取length为数组长度的一半，然后以arr[x],arr[x+length]为一组，并每一组进行插入排序 length减半，同样以arr[x],arr[x+length]……,arr[x+klength]为一组，每一组进行插入排序 循环，直到length=0循环停止 例子 算法代码123456789101112131415161718def Shell_Sort(arr): length=int((len(arr))/2) while length!=0: for i in range(length): for j in range(i+length,len(arr),length): temp=arr[j] x=j-length while x&gt;=0: if arr[x]&gt;temp: arr[x+length]=arr[x] x=x-length else: break arr[x+length]=temp print(arr) print(length) length=int(length/2) return arr","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"关于考研2","slug":"关于考研2","date":"2020-11-24T05:16:33.000Z","updated":"2020-11-24T05:30:43.101Z","comments":true,"path":"2020/11/24/关于考研2/","link":"","permalink":"http://example.com/2020/11/24/%E5%85%B3%E4%BA%8E%E8%80%83%E7%A0%942/","excerpt":"","text":"几天前的话，回了家一趟，和我姐姐聊了一下，我姐姐现在大四，还有一个月就要考研初试了，她和我讲了很多关于考研的事情，我基本也是确定了之后就是要考研了。 剑指2021 12月份~ 时间安排寒假前 先确定好自己要考研的院校 那些要考的专业科目开始看，但不是刷题很深地看，就是过一下，总结到blog，然后再自己敲代码去实现 开始背单词？好久没有学习英语了 还有这学期地课也不要落下了，开始准备复习 寒假后按照那个时间表跟着规划去做题，刷题，听课！ 感觉就是和高考差不都，一轮复习，又一轮复习的 考研科目英语100分 数学150分 政治100分 专业课：150分 数据结构45分，计算机组成原理45分，操作系统35分，计算机网络25分； 试卷题型结构：单项选择题，80分（40小题，每小题2分）；综合题，70分； 加油~愿韶华不负 ​ JAYSON","categories":[{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"}],"tags":[{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/tags/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"}]},{"title":"动态规划","slug":"动态规划","date":"2020-11-23T16:45:26.000Z","updated":"2020-12-01T09:47:01.139Z","comments":true,"path":"2020/11/24/动态规划/","link":"","permalink":"http://example.com/2020/11/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划算法，一个感觉和递归很像的东西。 递归：自上到下，慢慢到底部，不会记录每个问题的结果，内存消耗相对小，但会冲股份计算相同的问题，耗时多。 动态规划：自下到上，会记录每一个问题的结果，内存消耗相对比较大，但不会计算相同的问题，时间消耗较小。 动态规划解决问题的特点 最优化：即一个问题的子问题的解也是最优的 无后效性：即一个状态与之后的决策无关，如找零钱问题amount[5]与amount[5+x]无关 有重叠子问题：子问题之间不是独立的，可能子问题之间存在子问题调用关系 tips：有重叠子问题不是必要条件，但这是动态规划算法相比其他算法的优势 动态规划算法步骤 创建一个存放保存子问题状态的空间 找到每个状态之间的之间的关系 返回需要求的值 找零钱问题123456789101112131415class Solution: def coinChange(self, coins, amount: int) -&gt; int: coins.sort() dp=&#123;&#125; dp[0]=0 for i in range(1,amount+1): dp[i]=amount+1 for i in range(1,amount+1): for j in coins: if i&gt;=j: dp[i]=min(dp[i],(dp[i-j]+1)) if dp[amount]&lt;amount: return dp[amount] else: return -1","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PCA降维以及图片重构","slug":"PCA降维以及图片重构","date":"2020-11-22T08:50:34.000Z","updated":"2020-12-01T09:46:14.263Z","comments":true,"path":"2020/11/22/PCA降维以及图片重构/","link":"","permalink":"http://example.com/2020/11/22/PCA%E9%99%8D%E7%BB%B4%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E9%87%8D%E6%9E%84/","excerpt":"","text":"数值计算中有一个大作业是关于PCA的降维以及重构的，这里就总结一下，感觉还是蛮实用的。 PCA概念PCA即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。 PCA思想 数据中的信息是分布不均匀的，有些地方数据多，有些地方数据少 所以将一些少的信息去掉，对于原始数据是没有很大影响的，即抓住主要矛盾，忽略次要矛盾 经过推导可以知道协方差矩阵的特征值代表了数据包含的信息量，所以可以取大的特征值，舍弃掉小的从而完成降维 PCA降维步骤 去平均值(即去中心化)，即每一位特征减去各自的平均值。 计算协方差矩阵$\\frac{1}{n}XX^T$ 求协方差矩阵$\\frac{1}{n}XX^T$的特征值和特征向量 对特征值从大到小排序，选择其中最大的k个。然后将其对应的k个特征向量分别作为行向量组成特征向量矩阵P。 将数据转换到k个特征向量构建的新空间中，即Y=PX。 图像重构将上面的Y乘上P.T加上去中心化减去的值得到重构的图像 即： reconstruction=Y*P'+meanvalue实验过程 读取训练集图像，每一个人脸图像以一个列向量的形式存在，所以需要将每个图像重构成列向量 12345678910for j=1:img_num %逐一读取图像 image_name = img_path_list(j).name;%图像名 img = imread(strcat(file_path,image_name)); img = imresize(img, 0.2, &#x27;nearest&#x27;); [irow,icol] = size(img);%得到图片大小 temp = reshape(img,irow*icol,1);%将二维图片转为一维向量 % 每张图片的信息做为V的一列 Q(:,j)=temp; imgTrain=[imgTrain,temp];end 读取完人脸数据后，将数据零均值化，即人脸向量减去平均值脸向量。然后求出这组数据的协方差矩阵的特征值向量和特征值向量,这些单位特征向量可以形成一个特征空间，然后把原图像向量向这个特征空间中投影，就可以得到特征脸 12345678910111213141516171819202122232425262728293031323334353637383940m = mean(imgTrain,2); % 平均图像/行平均Train_Number = size(imgTrain,2);%列数%计算机每一张图片到均值图像的方差A = []; for i = 1 : Train_Number%对每一列 temp = double(imgTrain(:,i))-m; %每一张图与均值的差异 A = [A temp]; %差矩阵end%得到A的协方差矩阵并转置得到LL = A&#x27;*A; % L是协方差矩阵C=A*A&#x27;的转置%得到特征值与特征向量[V,D] = eig(L); %对角线上的元素是L|C的特征值.V:以特征向量为列的满秩矩阵，D：特征值对角矩阵。即L*V = V*D.L_eig_vec = [];%特征值向量max=0;for i = 1 : size(V,2)%对每个特征向量 max=max+D(i,i);endsum=0;for i = size(V,2):-1:size(V,2)-2%对每个特征向量 L_eig_vec = [L_eig_vec V(:,i)]*0;%集中对应的特征向量 sum=sum+D(i,i);endfor i = size(V,2)-3:-1:size(V,2)-9%对每个特征向量 L_eig_vec = [L_eig_vec V(:,i)]*0.05;%集中对应的特征向量 sum=sum+D(i,i);endfor i = size(V,2)-10:-1:1%对每个特征向量 L_eig_vec = [L_eig_vec V(:,i)];%集中对应的特征向量 sum=sum+D(i,i); if(sum/max&gt;0.99) break; endendEigenfaces = A * L_eig_vec; % 计算机协方差矩阵C的特征向量， %得到降维了的特征,A为每一张图像与均值图像的差构成的矩阵，TrainProjectedImages = [];%映射图像for i = 1 : img_num%对于每一个训练特征 temp = Eigenfaces&#x27;*double(Q(:,i)); TrainProjectedImages = [TrainProjectedImages temp]; %得到 L_eig_vec;end 人脸重建 人脸重建实验的目的是为了测试特征脸所携带的人脸信息。由于特征值的大小代表了其所对应的特征向量所携带的信息量，通过将最大的一些特征值对应的特征向量叠加就可以获得原图像中的大部分信息量，也就是所谓的主成分。这里先将所有特征值按从大到小的顺序排列。通过叠加特征向量的方式，就可以得到一组对原人脸的逼近特征脸。而将特征值加起来，正是总的信息量，也可以求出重构误差。 人脸识别 人脸识别即给出一个待识别的在测试集中的图像，计算该图像与已经有的人脸即训练集中的人脸的距离，距离最小的则认为该图片的人脸。 123456789101112131415161718192021for i=1:Testcols mImgTestCur = TestProjectedImages(:,i); vDisMin = 9999999999999; vClassMin = -1; for j=1:Traincols mImgTrainCur = TrainProjectedImages(:,j); mDis = mImgTestCur-mImgTrainCur; mDis = mDis.^2; vDis = sqrt(sum(mDis)); if vDis&lt;vDisMin vDisMin = vDis; m=j; end end name1=img_path_list_train(m).name; name1 =name1(6:7);%取名字的6-7位置的字符 name2=img_path_list_test(i).name; name2 =name2(6:7); if name2==name1 count=count+1; end 未完待续…","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://example.com/tags/matlab/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"深度优先dfs","slug":"深度优先dfs","date":"2020-11-21T16:57:02.000Z","updated":"2020-12-01T09:47:18.700Z","comments":true,"path":"2020/11/22/深度优先dfs/","link":"","permalink":"http://example.com/2020/11/22/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88dfs/","excerpt":"","text":"d 之所以总结一下dfs，是因为刷python题目时候遇到一个题，单词搜索问题，类似于dfs思想的题目，不太会做，然后就总结一下 什么是DFSDepth First Search英文的缩写，翻译过来就是“深度优先搜索”。 深度优先遍历的主要思想就是：首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点；当没有未访问过的顶点时，则回到上一个顶点，继续试探访问别的顶点，直到所有的顶点都被访问。 沿着某条路径遍历直到末端，然后回溯，再沿着另一条进行同样的遍历，直到所有的顶点都被访问过为止。 即：不撞南墙不回头 算法过程 任意选择一个起点v，访问该顶点 沿深度方向，依次遍历未访问邻节点 tips：每次访问后都要将访问的vist[]变成1 递归伪代码12345678DFS(dep,、、、） &#x2F;&#x2F;dep代表目前DFS的深度&#123; if(找到解 || 走不下去)&#123; 、、、 &#x2F;&#x2F;在此处进行相应的操作 return ; &#125; 枚举下一种情况，DFS（dep+1,、、、）&#125; 非递归伪代码1234567891011121314151617bool visited[MAXNODE]; &#x2F;&#x2F;顶点的访问标识数组void DFSInit(Graph G)&#123; for(i&#x3D;0; i&lt;G.VertexNum; i++)&#123; visited[i] &#x3D; false; &#125;&#125;void DFS(Graph G,int v)&#123; &#x2F;&#x2F;v:顶点数组中的序号 Visit[v]; visited[v]&#x3D;true; w &#x3D; FirstAdj(G,v); &#x2F;&#x2F;返回：v的第一个邻接点，0表示无邻接点 while(w!&#x3D;0)&#123; if(!visited[w]&#123; DFS(G,w); &#x2F;&#x2F;参数传递w-&gt;v &#125; w &#x3D; NextAdj(G,v,w); &#x2F;&#x2F;返回：v的在邻接点w后的邻接点，0表示不存在 &#125;&#125; 其中一种DFS序列：DFS(G,v1) = (v1,v2,v3,v6,v5,v7,v4,v8,v9) 小结dfs即找准了一条路，如果满足判定成功条件或者失败条件（撞南墙）就返回上一个节点，再从这个节点继续找下一个，再撞再回溯。 单词搜索问题12345678910111213def dfs(self,i,j,cmap,word): if len(word)==0: #撞南墙 return True #撞南墙 elif i&gt;=len(cmap) or i&lt;0 or j&lt;0 or j&gt;=len(cmap[0]) or word[0]!=cmap[i][j]: return False temp=cmap[i][j] cmap[i][j]=&#x27;#&#x27; res =self.dfs(i+1,j,cmap,word[1:]) or self.dfs(i-1, j, cmap, word[1:]) or self.dfs(i, j+1, cmap, word[1:]) or self.dfs(i, j-1, cmap, word[1:]) #四种方向，其中有一种return True那这个节点即return True cmap[i][j]=temp return res 未完待续……………………………….","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"关于考研","slug":"postdsa","date":"2020-11-19T07:24:48.000Z","updated":"2020-12-01T09:46:36.040Z","comments":true,"path":"2020/11/19/postdsa/","link":"","permalink":"http://example.com/2020/11/19/postdsa/","excerpt":"","text":"d 现在是2020.11.19，距离大四毕业还有一年半的时间，还有半年我就要面临考研以及还是就业的选择，说实话，我现在是十分犹豫的。 我之所以想考研其实很大部分原因是因为感觉自己其实并没有准备好直接就进入职场经历那雨打风吹，而且读完研究生的薪资待遇确实是和本科生不同，可能是为了“钱途”吧，本来打算保不了研就直接从业的我产生了读研的想法。 关于之后这大半年其实计算机这门学科，只要你肯花时间去专研，琢磨，总结，深入，不停写码肯定可以收获不小的成功，哪怕不能做到最最最顶尖，但肯定是高于水准线之上很多的。我的想法是： 不断地刷题，刷leetcode，现在我把matrix上字节跳动的题目刷完就去刷leetcode了 总结，将知识点分类，或者觉得有用的东西弄到我的blog上，并且不断地美化自己的blog。 总结计网，计组，操作系统，计网的知识点到blog上，并且深入地做一些相关地研究或者实验去加深巩固，而且因为这学期是有计网2这个科目的，所以计网是放在第一优先级的 做一些实际的项目练手 考研科目英语100分 数学150分 政治100分 专业课：150分 数据结构45分，计算机组成原理45分，操作系统35分，计算机网络25分； 试卷题型结构：单项选择题，80分（40小题，每小题2分）；综合题，70分； 加油~愿韶华不负 ​ JAYSON","categories":[{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"}],"tags":[]},{"title":"关于考研","slug":"关于考研","date":"2020-11-19T07:24:48.000Z","updated":"2020-11-19T07:43:46.425Z","comments":true,"path":"2020/11/19/关于考研/","link":"","permalink":"http://example.com/2020/11/19/%E5%85%B3%E4%BA%8E%E8%80%83%E7%A0%94/","excerpt":"","text":"d 现在是2020.11.19，距离大四毕业还有一年半的时间，还有半年我就要面临考研以及还是就业的选择，说实话，我现在是十分犹豫的。 我之所以想考研其实很大部分原因是因为感觉自己其实并没有准备好直接就进入职场经历那雨打风吹，而且读完研究生的薪资待遇确实是和本科生不同，可能是为了“钱途”吧，本来打算保不了研就直接从业的我产生了读研的想法。 关于之后这大半年其实计算机这门学科，只要你肯花时间去专研，琢磨，总结，深入，不停写码肯定可以收获不小的成功，哪怕不能做到最最最顶尖，但肯定是高于水准线之上很多的。我的想法是： 不断地刷题，刷leetcode，现在我把matrix上字节跳动的题目刷完就去刷leetcode了 总结，将知识点分类，或者觉得有用的东西弄到我的blog上，并且不断地美化自己的blog。 总结计网，计组，操作系统，计网的知识点到blog上，并且深入地做一些相关地研究或者实验去加深巩固，而且因为这学期是有计网2这个科目的，所以计网是放在第一优先级的 做一些实际的项目练手 考研科目英语100分 数学150分 政治100分 专业课：150分 数据结构45分，计算机组成原理45分，操作系统35分，计算机网络25分； 试卷题型结构：单项选择题，80分（40小题，每小题2分）；综合题，70分； 加油~愿韶华不负 ​ JAYSON","categories":[{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"}],"tags":[]},{"title":"链表in python","slug":"链表in-python","date":"2020-11-18T18:09:45.000Z","updated":"2020-12-01T09:47:44.190Z","comments":true,"path":"2020/11/19/链表in-python/","link":"","permalink":"http://example.com/2020/11/19/%E9%93%BE%E8%A1%A8in-python/","excerpt":"","text":"链表链表是python中特别重要且实用的数据结构，c++中的链表实现是分为指针和静态的，但因为python中没有指针结构，所以是只有静态的实现 链表节点的定义1234class ListNode: def __init__(self, x): self.val = x self.next = None 节点有两个内置变量，一个是val即储存的值。另一个是next，即指向的下一个节点。 链表的构建12345678910head= ListNode(5)for i in range(1,3): node = ListNode(i) cur = head.next if cur== None: head.next = node else: while cur.next != None: cur = cur.next cur.next = node 理解：头head是指向一个一般不动的，所以你要在头后面加数的话，得先建一个temp=head，然后改变temp在链表的位置使其指向最后一个数，再temp.next=node 链表求和123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 is None: return l2 elif l2 is None: return l1 head1=reverse(l1) head2=reverse(l2) head=None flag=0 while head1 is not None or head2 is not None: if head1 is None: node=ListNode(0) head1=node elif head2 is None: node = ListNode(0) head2 = node sum_num=head1.val+head2.val+flag if sum_num&gt;=10: flag=1 sum_num=sum_num%10 else: flag=0 temp=ListNode(sum_num) if head==None: head=temp else: cur=head while cur.next!=None: cur=cur.next cur.next=temp head1=head1.next head2=head2.next temp=head if flag==1: while temp.next!=None: temp=temp.next temp.next=ListNode(1) head=reverse(head) if head.val==0: head=head.next return head 判断链表是否有环1234567891011121314class Solution: def hasCycle(self, head: ListNode) -&gt; bool: slow_list = head fast_list = head while slow_list.next is not None and fast_list.next is not None: if fast_list.next.next is None: break slow_list=slow_list.next fast_list=fast_list.next.next if slow_list.val==fast_list.val: print(&quot;True&quot;,end=&#x27;&#x27;) return &#x27;&#x27; print(&quot;False&quot;,&#x27;&#x27;) return &#x27;&#x27;","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"基础数据结构list","slug":"lilst","date":"2020-11-16T09:32:51.000Z","updated":"2020-12-01T09:45:55.803Z","comments":true,"path":"2020/11/16/lilst/","link":"","permalink":"http://example.com/2020/11/16/lilst/","excerpt":"","text":"List数据类型是python中最为常用的数据类型，在这里总结一下对list的理解 列表数据类型是python中最为常用的数据类型，在这里总结一下对list的理解，以及常用的操作 List数据类型的理解列表类型与c++的数组和STL的vector十分像，且列表中的元素类型不是固定的，十分有意思。与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。 列表的创建list=[]//创建空列表 list = [‘physics’, ‘chemistry’, 1997, 2000] list=list(range()) 列表的基本操作添加元素在列表的最后一位添加元素 list.append(obj) 插入元素list.insert(index,obj) 移除元素移除列表中一个元素，并返回列表的值，默认是最后一位 list.pop([index=-1]) 列表取反list.reverse() 列表排序该方法没有返回值，但是会对列表的对象进行排序。 list.sort(cmp=None, key=None, reverse=False) 降序vowels.sort(reverse=True) 升序升序是默认的即：list.sort() vowels.sort(reverse=False) 链表切片切片操作确实还是蛮方便的，python中可以很轻易地实现对列表的切割 1list2=list1[a:b] 左闭右开即取a不取b [a:],[:b] #只取一边 其他列表操作 cmp(list1,list2) len(list) max(list) min(list) list(seq)//将元组转换为列表 list.count(obj)//统计某个元素在列表中出现的次数 list.index(obj)//从列表中找出某个值第一个匹配项的索引位置 list.remove(obj)//移除列表中某个值的第一个匹配项 列表的遍历 for i,j in list: for i in range(n): 以上是一些列表的基本操作，一般其实用不到特别复杂的操作，未完待续………","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"numpy","slug":"numpy","date":"2020-11-15T14:32:51.000Z","updated":"2020-12-01T09:46:04.260Z","comments":true,"path":"2020/11/15/numpy/","link":"","permalink":"http://example.com/2020/11/15/numpy/","excerpt":"","text":"[toc] 在数值计算中numpy特别使用，所以做一下关于numpy用法的记录 numpyimport numpy as np ARRAY的创建np.array()e.g. np.array([[1,1,1], ​ [[1,1,1]) np.zeros()全零的矩阵e.g. np.zeros([3,3]) np.ones()全1的矩阵e.g. np.ones([3,3]) np.empty()空e.g. np.empty([3,3]) np.full()e.g. array=np.full([3,3],6) #全是6的3*3矩阵 ARRAY的属性array.shape几行几列对于图像来说： ​ img.shape[0]：图像的垂直尺寸（高度） ​ img.shape[1]：图像的水平尺寸（宽度） ​ img.shape[2]：图像的通道数 而对于矩阵来说： ​ shape[0]：表示矩阵的行数 ​ shape[1]：表示矩阵的列数 array.size大小array.T转置array.real虚数的实部array.imag实数的虚部ARRAY的操作np.mean()np.mean(arr) #求所有值的均值 np.mean(arr,axis=0)#按列求均值 np.mean(arr,axis=1)#按行求均值 array.copy ()复制拷贝e.g. cc=array.copy() ！！！cc=array 这个是浅拷贝，cc改变array也会改变 array.reshape()array.reshape(2,8) 重塑形状，改变数组的行和列array.resize()resize()和reshape()的区别是前者数组自身会改变，后者不会array.flatten直接将数组拉平编程一维的array.max()最大值np.matmul(a,b)矩阵乘法 np.tile()将数组沿y或x扩大倍数np.(a,(2,1))//第一个是y，第二个是x轴 ARRAY的索引切片array[1:3,1:3]#变成1，2行列的数组 python索引是前面闭括号，后面开括号键对索引array[[row1,row2],[col1,col2]] 一一对应e.g. array[[0,2],[1,3]] np.nditer 迭代器e.g. for i in np.nditer(array): ​ print(i) ARRAY的拼接拆分拼接vstack上下np.vstack([array1,array2]) hstack左右np.hstack([array1,array2]) stack维度np.stack([array1,array2]) 拆分vsplithsplitsplit图像的读取库import matplotlib.pyplot as plt import matplotlib.image as mpimg import numpy as np 读取img=mpimg.imread(‘cat.jpg’) 此时 img 就已经是一个 np.array 了，可以对它进行任意处理showplt.imshow(img) # 显示图片 plt.axis(‘off’) # 不显示坐标轴 plt.show()","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"first_article","slug":"first-article","date":"2020-10-25T16:15:37.000Z","updated":"2020-10-26T04:38:59.911Z","comments":true,"path":"2020/10/26/first-article/","link":"","permalink":"http://example.com/2020/10/26/first-article/","excerpt":"","text":"first第一个blog_text","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-10-25T15:43:49.321Z","updated":"2020-10-25T15:43:49.321Z","comments":true,"path":"2020/10/25/hello-world/","link":"","permalink":"http://example.com/2020/10/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"计网","slug":"计网","permalink":"http://example.com/categories/%E8%AE%A1%E7%BD%91/"},{"name":"黑客","slug":"黑客","permalink":"http://example.com/categories/%E9%BB%91%E5%AE%A2/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/categories/leetcode/"},{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"},{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"信号与系统","slug":"信号与系统","permalink":"http://example.com/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"name":"饶舌","slug":"饶舌","permalink":"http://example.com/categories/%E9%A5%B6%E8%88%8C/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"计网","slug":"计网","permalink":"http://example.com/tags/%E8%AE%A1%E7%BD%91/"},{"name":"黑客","slug":"黑客","permalink":"http://example.com/tags/%E9%BB%91%E5%AE%A2/"},{"name":"考研","slug":"考研","permalink":"http://example.com/tags/%E8%80%83%E7%A0%94/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"},{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"信号与系统","slug":"信号与系统","permalink":"http://example.com/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"name":"饶舌","slug":"饶舌","permalink":"http://example.com/tags/%E9%A5%B6%E8%88%8C/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/tags/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"matlab","slug":"matlab","permalink":"http://example.com/tags/matlab/"}]}