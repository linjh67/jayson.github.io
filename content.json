{"meta":{"title":"Jayson","subtitle":null,"description":"这里是一个要考研的大三程序狗的博客，喜欢跳舞，饶舌音乐，健身，在这里会记录自己的生活以及学习","author":"jayson","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2020-11-15T14:46:10.000Z","updated":"2020-11-23T14:37:50.116Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-15T14:49:34.000Z","updated":"2020-11-23T14:37:41.910Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"404","date":"2020-11-22T13:35:30.000Z","updated":"2020-11-22T13:37:39.399Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-11-22T13:35:01.000Z","updated":"2020-11-22T13:36:11.565Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-11-22T13:35:12.000Z","updated":"2020-11-22T13:36:46.270Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"插值","slug":"插值","date":"2020-11-28T17:30:30.000Z","updated":"2020-11-28T17:51:25.614Z","comments":true,"path":"2020/11/29/插值/","link":"","permalink":"http://example.com/2020/11/29/%E6%8F%92%E5%80%BC/","excerpt":"","text":"","categories":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}]},{"title":"python下函数与图像的显示","slug":"python下函数与图像的显示","date":"2020-11-27T16:57:10.000Z","updated":"2020-11-27T18:03:24.278Z","comments":true,"path":"2020/11/28/python下函数与图像的显示/","link":"","permalink":"http://example.com/2020/11/28/python%E4%B8%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%98%BE%E7%A4%BA/","excerpt":"","text":"数值计算里为了显示函数的图像，总结一下python里相关的知识。 调库matplotlib.pyplot和MATLAB很相似，之中各种状态通过函数调用保存。 123import numpy as npimport matplotlib.pyplot as pltfrom pylab import * np.arange()np.arange(a,b,step) #step是步长 函数返回一个有终点和起点的固定步长的排列，如[1,2,3,4,5]，起点是1，终点是6，步长为1。 plt.plot()plt.plot(x,y,format_string,**kwargs) 函数用来确定x,y，以及图像的一些颜色之类的特征 参数 说明 x X轴数据，列表或数组，可选 y Y轴数据，列表或数组 format_string 控制曲线的格式字符串，可选 **kwargs 第二组或更多(x,y,format_string)，可画多条曲线 format_string 由颜色字符、风格字符、标记字符组成 颜色字符 &#39;b&#39; 蓝色 &#39;m&#39; 洋红色 magenta &#39;g&#39; 绿色 &#39;y&#39; 黄色 &#39;r&#39; 红色 &#39;k&#39; 黑色 &#39;w&#39; 白色 &#39;c&#39; 青绿色 cyan &#39;#008000&#39; RGB某颜色 &#39;0.8&#39; 灰度值字符串 多条曲线不指定颜色时，会自动选择不同颜色 风格字符 &#39;‐&#39; 实线 &#39;‐‐&#39; 破折线 &#39;‐.&#39; 点划线 &#39;:&#39; 虚线 &#39;&#39; &#39; &#39; 无线条 标记字符 &#39;.&#39; 点标记 &#39;,&#39; 像素标记(极小点) &#39;o&#39; 实心圈标记 &#39;v&#39; 倒三角标记 &#39;^&#39; 上三角标记 &#39;&gt;&#39; 右三角标记 &#39;0&lt;&#39; 左三角标记…等等 plt.show()显示图像 plt.figure()要显示的图像的名字 e.g. 1plt.figure(&quot;my_pic&quot;) plt.subplot()把多张图显示到一个显示界面上。 plt.subplot(row,col,code)#生成row行，col列，code是编号 12345678910111213t=np.arange(0.0,2.0,0.1)s=np.sin(t*np.pi)plt.subplot(2,2,1) #要生成两行两列，这是第一个图plt.subplot(&#x27;行&#x27;,&#x27;列&#x27;,&#x27;编号&#x27;)plt.plot(t,s,&#x27;b--&#x27;)plt.ylabel(&#x27;y1&#x27;)plt.subplot(2,2,2) #两行两列,这是第二个图plt.plot(2*t,s,&#x27;r--&#x27;)plt.ylabel(&#x27;y2&#x27;)plt.subplot(2,2,3)#两行两列,这是第三个图plt.plot(3*t,s,&#x27;m--&#x27;)plt.subplot(2,2,4)#两行两列,这是第四个图plt.plot(4*t,s,&#x27;k--&#x27;)plt.show() y=cos(x)图像1234567x=np.arange(-5.0,5.0,0.01)y1=np.cos(x)print(y1.shape[0])plt.figure(1)plt.subplot(211)plt.plot(x,y1,&#x27;b&#x27;)plt.show()","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"拟合","slug":"拟合","date":"2020-11-26T09:09:47.000Z","updated":"2020-11-28T17:52:00.068Z","comments":true,"path":"2020/11/26/拟合/","link":"","permalink":"http://example.com/2020/11/26/%E6%8B%9F%E5%90%88/","excerpt":"","text":"拟合，插值，逼近是数学分析的三大基础工具，在这里总结一下拟合 拟合：已知点列，整体靠近它们 插值：已知点列并且完全经过点列 逼近：已知曲线，或者点列，通过逼近使得构造的函数无限靠近它们 拟合拟合定义 最小二乘问题最小二乘即f(X)-g(X)的范数是2-范数，这种问题就是最小二乘问题。 所以，即找g(x)使得$$||f(x)-g(x)||2=\\sqrt{\\sum{i=0}^n(f(x_i)-g(x_i))^2}$$取到最小值，记为评价函数$L(a_1,a_2…..a_n)$ 欲取得评价函数最小值，则要对每个变量$a_i$的偏导等于零，即：$$\\frac{\\partial L}{\\partial a_i}=0 ,i\\in(1,n)$$ 线性拟合 $$f(x)=ax+b$$ 低次多项式拟合$$f(x)=ax^3+bx^2+cx+d$$ 指数拟合 $$f(x)=e^{ax+b}$$ $$\\downarrow$$ $$\\ln{f(x)}=ax+b$$ 将$\\ln{f(x)}$记为y,则变成了线性拟合y=ax+b 线性角度的最小二乘从微积分的视角来看，最小二乘法相当于求解约等方程组，那么最小二乘法的线性代数视角又是什么呢？ 先来看向量的投影： b,p,e 是3个向量，其中p是b 在平面上的投影， e是b和p 的误差向量，e=b-p 。平面可以看作二维向量张成的向量空间，p 在该空间上。将向量投影到向量空间有什么意义呢？这要从方程 Ax=b 说起。 小明根据测量结果得到了一个方程组，并将它进一步化简为矩阵的形式： 对于小明的数据来说， Ax=b无解，实际上大多数这种类型的方程都无解。A的列空间的含义是方程组有解时b 的取值空间，当b 不在 A的列空间时，方程无解。具体来说，当A 是行数大于列数的长方矩阵时，意味着方程组中的方程数大于未知数的个数，此时肯定无解。 虽然方程无解，但我们还是希望能够运算下去，这就需要换个思路——不追求可解，转而寻找最能接近问题的解。对于无解方程Ax=b 来说，Ax 总是在列空间上（因为列空间本来就是由 Ax确定的，和b 无关），而 b就不一定了，所以需要微调 ，将p 调整至列空间中最接近它的一个，此时Ax=b 变成了： p就是 b在 A的列空间上的投影， x上加一个小帽子表示x 的估计值。当然，因为方程无解，所以本来也不可能有 Ax=b。此时问题转换为寻找最好的估计值 ，使它尽可能满足原方程： 在上图中，A的秩是2，平面表示A的列空间，平面上的向量有无数个，其中最接近b 的当然是b 在平面上的投影，因为只有在这时 b-p 才能产生模最小的误差向量。 如何求得估计值呢？ 在小明的测量数据中，A的列空间是一个超平面，A的两个列向量都在这个超平面上，b和p 的误差向量e垂直于超平面，因此e也垂直于超平面上的所有向量，这意味着e 和 A的两个列向量的点积为0。 将二者归纳为一个矩阵方程： 矩阵方程已经去掉了关于 的信息，通过该方程可进一步求得估计值： 这就是最终结果了，它是由矩阵方程推导而来的，所以这个结果叫做“正规方程”。 还有一种更简单的方式可以得到正规方程。Ax=b无解的原因是因为 A 是一个长方矩阵，只要在等式两侧同时乘以 AT，就可以把长方矩阵转换成方阵，进而求解。 多项式的非线性拟合y=cosx求出A，b,然后套公式就行了：$$x=(A^TA)^{-1}A^Tb$$ 12345678910111213def least_squres(n): b=np.zeros(9)#测试数据为8 for i in range(9): b[i]=cos(-pi+(6/8)*i) A=np.zeros([9,n+1]) #n次方,则有n+1个c_i for i in range(9): for j in range(n+1): A[i][j]=(-pi+(6/8)*i)**j #x=np.zeros(n+1) x=np.dot(np.linalg.inv((np.dot(A.T,A))),np.dot(A.T,b)) print(x) return x #一共有5个曲线，蓝色和绿色分别是n=2和n=3的时候，红色，黑色，白色分别是n=4,n=6,y=cosx的时候，可以看到n=2,3时候与y=cosx有一定差别,而用n=4,6的多项式拟合y=cosx与原图基本是重合的。","categories":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}]},{"title":"排序算法","slug":"排序算法","date":"2020-11-24T12:53:16.000Z","updated":"2020-11-25T13:33:02.476Z","comments":true,"path":"2020/11/24/排序算法/","link":"","permalink":"http://example.com/2020/11/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"复习数据结构，然后总结一下数据结构的排序算法，并再用python全都实现一次。 排序比较排序冒泡排序冒泡排序是最基本的排序算法，比较相邻的元素，将大（小）的放到后面。每一躺循环，将最大（最小）的交换到最后面。 算法流程 第一躺循环，从arr[0]到arr[N-1]，两两比较，若arr[x]&gt;arr[x+1]，则进行交换，从而使得最后在arr[N-1]的是最大的数 下一趟循环，则变成从arr[0]到arr[N-2] 重复直到完成最后一趟循环即arr[0]到arr[1]的比较 算法评价一共进行了N-1次循环，确定了N-1次要确定的最大数 稳定，平均时间复杂度为$o(n^2)$ 算法代码1234567891011def Bubble_Sort(arr): length=len(arr) j=length-1 for i in range(length-1): for x in range(j): if arr[x]&gt;arr[x+1]: temp=arr[x] arr[x]=arr[x+1] arr[x+1]=temp j-=1 return arr 插入排序顾名思义，插入排序(Insertion Sort)就是将一个元素插入到已经排序好的序列中，这里是arr[x]插入到已经排序好的(arr[0]~arr[x-1])中 算法流程 index左边是有序的，右边是待插入的，index是从1开始，N-1结束 两种选择： 从右往左一个个两两交换，直到遇到比arr[index]小的数停止 把arr[index]用temp保存，找到要插入的位置insert_index，即是最后一个比temp大的数的位置，将arr[insert_index]到arr[index-1]全都往后移一位，然后再插入 算法代码 第一种 12345678def Insertion_Sort(arr): for i in range(1,len(arr)): for j in range(i,0,-1): if arr[j]&lt;arr[j-1]: temp=arr[j] arr[j]=arr[j-1] arr[j-1]=temp return arr 123456789def Insertion_Sort(arr): for i in range(1,len(arr)): temp=arr[i] j=i-1 while j&gt;=0 and arr[j]&gt;temp: arr[j+1]=arr[j] j=j-1 arr[j+1]=temp return arr 选择排序选择排序就是每次在待选择的序列里选择一个最小的到最前面，感觉比前面两种垃圾一点。 算法流程 找到列表中最小的元素将其与列表第一个元素交换 其次，将剩下的待排序的元素中找到最小的元素将其与第二个元素交换 重复，完成N-1躺排序 时间复杂度：$o(n^2)$ 算法代码1234567891011def Selection_Sort(arr): for i in range(len(arr)): min_index=i for j in range(i+1,len(arr)): if arr[j]&lt;arr[min_index]: min_index=j if min_index!=i: temp=arr[i] arr[i]=arr[min_index] arr[min_index]=temp return arr 快速排序快速排序有动态规划，递归的思想，将大的慢慢地分成小的，即分治法，然后还有挖坑填数。 时间复杂度 最好：o(nlogn) 最坏：$o(n^2)$ 算法流程 把数组的第一个数当作基准线 通过一躺排序将数据分成两部分，左边是比基准线pivot小的，有部分是比基准线大的。（这里用的是挖坑法）下面介绍 递归，左边在分成两部分，右边也分成两部分一直递归成一个数就是完成了排序 挖坑法（如下例子）表格中红色的字体为需要填的坑，绿色的字体为已经移动过的数据。 1.刚开始，i 和 j 分别指向数组头和数组尾，即 i = 0，j = 9，基准数取第一个数，即index = array[i] = array[0] = 23。 此时，array[0]的值已经存在了index，因此array[0]的位置就好像被挖了个坑，可以填充一个数。 因此，我们从位置 j 开始向左寻找比index小的数，当 j = 8 时，符合条件，于是我们将array[8]的值填到array[0] ，即将9填入array[0]，并将 i 向右移动一个位置，即 i++。从位置 j 向左寻找比index小的数，并在寻找到后填入坑中，用代码表示如下。 123456while (i &lt; j &amp;&amp; array[j] &gt;= index) &#123; // 向左寻找第一个小于index的数 j--;&#125;if (i &lt; j) &#123; array[i++] = array[j]; // 将array[j]填入array[i]，并将i向右移动&#125; 此时，array数组如下图。 2.因为array[0]的坑被array[8]填了，于是array[8]的位置又成了一个新的坑。此时我们从位置 i 开始向右寻找比index大的数，当 i = 2 时符合条件，于是我们将array[2]的值填到array[8] ，即将37填入array[8]，并将 j 向左移动一个位置，即 j–。从位置 i 向右寻找比index大的数，并在寻找到后填入坑中，用代码表示如下（跟上面相似）。 123456while (i &lt; j &amp;&amp; array[i] &lt; index) &#123;// 向右寻找第一个大于index的数 i++;&#125;if (i &lt; j) &#123; array[j--] = array[i]; // 将array[i]填入array[j]，并将j向左移动&#125; 此时，array数组如下图。 3.同样的，array[8]的坑被array[2]填了，于是array[2]的位置又成了一个新的坑。此时我们从位置 j 开始向左寻找比index小的数，当 j = 5 时符合条件，于是我们将array[5]的值填到array[2] ，即将21填入array[2]，并将 i 向右移动一个位置，即 i++，此时array数组如下图。 4.同样的，array[2]的坑被array[5]填了，于是array[5]的位置又成了一个新的坑。此时我们从位置 i 开始向右寻找比index大的数，当 i = 3 时符合条件，于是我们将array[3]的值填到array[5] ，即将89填入array[5]，并将 j 向左移动一个位置，即 j–，此时array数组如下图。 5.同样的，array[5]的坑被array[3]填了，于是array[3]的位置又成了一个新的坑。此时我们从位置 j 开始向左寻找比index小的数，当 j = 4 时符合条件，于是我们将array[4]的值填到array[3] ，即将2填入array[3]，并将 i 向右移动一个位置，即 i++，此时array数组如下图。 6.此时，我们发现 i = j，结束遍历，并将index填入array[4]，即将23填入array[4]，此时array数组如下图。此时，array[4]左边的数据全比array[4]小，而array[4]右边的数据全比array[4]大。 7.接下去，我们只需要对array[4]两边的数据分别在进行上面的操作即可（分治法），如下图。 分治的代码可以写成如下： 12quickSort(array, low, i - 1); // 递归调用，分治quickSort(array, i + 1, high); // 递归调用，分治 算法代码12345678910111213141516171819202122232425262728def Quick_Sort(arr,first,last): if first&gt;=last: return arr pivot=arr[first] count=0 #count为0的时候就是从右往左选比temp小的数 #count为1的时候就是从左往右选比temp大的数 i=first j=last-1 while i!=j: if count==0: if arr[j]&lt;pivot: arr[i]=arr[j] count=1 i+=1 else: j-=1 else: if arr[i]&gt;=pivot: arr[j]=arr[i] count=0 j-=1 else: i+=1 arr[i]=pivot Quick_Sort(arr,first,i) Quick_Sort(arr,i+1,last) return arr 归并排序归并排序的思想是分治法，将一个待排序的数组分成两半，不断地分直到数组中只有一个数，然后再返回去，从底向上的去排序 算法流程 将一个数组一切为二分成两半 递归地切，结束条件是数组长度为1 底层的向上开始排序，方法为新建一个空数组temp，因为对于每一个数组切的一个组来说，它的两个子组其实都是已经排好序的了，所以只要比较两个子组的第一个数，一直将小的那个压进temp里即可 例子 当我们要排序这样一个数组的时候，归并排序法首先将这个数组分成一半。如图： 然后想办法把左边的数组给排序，右边的数组给排序，之后呢再将它们归并起来。当然了当我们对左边的数组和右边的素组进行排序的时候，再分别将左边的数组和右边的数组分成一半，然后对每一个部分先排序，再归并。如图： 对于上面的每一个部分呢，我们依然是先将他们分半，再归并，如图： 分到一定细度的时候，每一个部分就只有一个元素了，那么我们此时不用排序，对他们进行一次简单的归并就好了。如图： 归并到上一个层级之后继续归并，归并到更高的层级，如图： 直至最后归并完成。 只不过现在计算机中时间的效率要比空间的效率重要的多。无论是内存也好还是硬盘也好可以存储的数据越来越多，所以设计一个算法，时间复杂度是要优先考虑的。整体来讲我们要使用三个索引来在数组内进行追踪。 \\** 蓝色的箭头表示最终选择的位置，而红色的箭头表示两个数组当前要比较的元素，比如当前是2与1比较，1比2小，所以1放到蓝色的箭头中，**蓝色的箭头后移，1的箭头后移。 然后2与4比较，2比4小那么2到蓝色的箭头中，蓝色箭头后移，2后移，继续比较……. \\** 算法代码123456789101112131415161718ef Merge_Sort(arr): if len(arr)==1: return arr else: a=Merge_Sort(arr[:int(len(arr)/2)]) b=Merge_Sort(arr[int(len(arr)/2):]) temp=[] while len(a)!=0 or len(b)!=0: if len(a)==0: temp.append(b.pop(0)) elif len(b)==0: temp.append(a.pop(0)) else: if a[0]&lt;b[0]: temp.append(a.pop(0)) else: temp.append(b.pop(0)) return temp 希尔排序希尔排序可以说是高级版的插入排序，还挺牛逼的，原理大概就是先将待排序的数组大致做一个排序，然后这个数组宏观上看起来就是顺序的，所以最后到最细致的插入排序的时候其实基本就不用怎么交换。 算法流程 确定分组，取length为数组长度的一半，然后以arr[x],arr[x+length]为一组，并每一组进行插入排序 length减半，同样以arr[x],arr[x+length]……,arr[x+klength]为一组，每一组进行插入排序 循环，直到length=0循环停止 例子 算法代码123456789101112131415161718def Shell_Sort(arr): length=int((len(arr))/2) while length!=0: for i in range(length): for j in range(i+length,len(arr),length): temp=arr[j] x=j-length while x&gt;=0: if arr[x]&gt;temp: arr[x+length]=arr[x] x=x-length else: break arr[x+length]=temp print(arr) print(length) length=int(length/2) return arr","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"关于考研2","slug":"关于考研2","date":"2020-11-24T05:16:33.000Z","updated":"2020-11-24T05:30:43.101Z","comments":true,"path":"2020/11/24/关于考研2/","link":"","permalink":"http://example.com/2020/11/24/%E5%85%B3%E4%BA%8E%E8%80%83%E7%A0%942/","excerpt":"","text":"几天前的话，回了家一趟，和我姐姐聊了一下，我姐姐现在大四，还有一个月就要考研初试了，她和我讲了很多关于考研的事情，我基本也是确定了之后就是要考研了。 剑指2021 12月份~ 时间安排寒假前 先确定好自己要考研的院校 那些要考的专业科目开始看，但不是刷题很深地看，就是过一下，总结到blog，然后再自己敲代码去实现 开始背单词？好久没有学习英语了 还有这学期地课也不要落下了，开始准备复习 寒假后按照那个时间表跟着规划去做题，刷题，听课！ 感觉就是和高考差不都，一轮复习，又一轮复习的 考研科目英语100分 数学150分 政治100分 专业课：150分 数据结构45分，计算机组成原理45分，操作系统35分，计算机网络25分； 试卷题型结构：单项选择题，80分（40小题，每小题2分）；综合题，70分； 加油~愿韶华不负 ​ JAYSON","categories":[{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"}],"tags":[{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/tags/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"}]},{"title":"动态规划","slug":"动态规划","date":"2020-11-23T16:45:26.000Z","updated":"2020-11-23T17:00:17.435Z","comments":true,"path":"2020/11/24/动态规划/","link":"","permalink":"http://example.com/2020/11/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划算法，一个感觉和递归很像的东西。 递归：自上到下，慢慢到底部，不会记录每个问题的结果，内存消耗相对小，但会冲股份计算相同的问题，耗时多。 动态规划：自下到上，会记录每一个问题的结果，内存消耗相对比较大，但不会计算相同的问题，时间消耗较小。 动态规划解决问题的特点 最优化：即一个问题的子问题的解也是最优的 无后效性：即一个状态与之后的决策无关，如找零钱问题amount[5]与amount[5+x]无关 有重叠子问题：子问题之间不是独立的，可能子问题之间存在子问题调用关系 tips：有重叠子问题不是必要条件，但这是动态规划算法相比其他算法的优势 动态规划算法步骤 创建一个存放保存子问题状态的空间 找到每个状态之间的之间的关系 返回需要求的值 找零钱问题123456789101112131415class Solution: def coinChange(self, coins, amount: int) -&gt; int: coins.sort() dp=&#123;&#125; dp[0]=0 for i in range(1,amount+1): dp[i]=amount+1 for i in range(1,amount+1): for j in coins: if i&gt;=j: dp[i]=min(dp[i],(dp[i-j]+1)) if dp[amount]&lt;amount: return dp[amount] else: return -1","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PCA降维以及图片重构","slug":"PCA降维以及图片重构","date":"2020-11-22T08:50:34.000Z","updated":"2020-11-22T12:57:18.856Z","comments":true,"path":"2020/11/22/PCA降维以及图片重构/","link":"","permalink":"http://example.com/2020/11/22/PCA%E9%99%8D%E7%BB%B4%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E9%87%8D%E6%9E%84/","excerpt":"","text":"数值计算中有一个大作业是关于PCA的降维以及重构的，这里就总结一下，感觉还是蛮实用的。 PCA概念PCA即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。 PCA思想 数据中的信息是分布不均匀的，有些地方数据多，有些地方数据少 所以将一些少的信息去掉，对于原始数据是没有很大影响的，即抓住主要矛盾，忽略次要矛盾 经过推导可以知道协方差矩阵的特征值代表了数据包含的信息量，所以可以取大的特征值，舍弃掉小的从而完成降维 PCA降维步骤 去平均值(即去中心化)，即每一位特征减去各自的平均值。 计算协方差矩阵$\\frac{1}{n}XX^T$ 求协方差矩阵$\\frac{1}{n}XX^T$的特征值和特征向量 对特征值从大到小排序，选择其中最大的k个。然后将其对应的k个特征向量分别作为行向量组成特征向量矩阵P。 将数据转换到k个特征向量构建的新空间中，即Y=PX。 图像重构将上面的Y乘上P.T加上去中心化减去的值得到重构的图像 即：$$reconstruction=Y*P’+meanvalue$$ 实验过程 读取训练集图像，每一个人脸图像以一个列向量的形式存在，所以需要将每个图像重构成列向量 12345678910for j=1:img_num %逐一读取图像 image_name = img_path_list(j).name;%图像名 img = imread(strcat(file_path,image_name)); img = imresize(img, 0.2, &#x27;nearest&#x27;); [irow,icol] = size(img);%得到图片大小 temp = reshape(img,irow*icol,1);%将二维图片转为一维向量 % 每张图片的信息做为V的一列 Q(:,j)=temp; imgTrain=[imgTrain,temp];end 读取完人脸数据后，将数据零均值化，即人脸向量减去平均值脸向量。然后求出这组数据的协方差矩阵的特征值向量和特征值向量,这些单位特征向量可以形成一个特征空间，然后把原图像向量向这个特征空间中投影，就可以得到特征脸 12345678910111213141516171819202122232425262728293031323334353637383940m = mean(imgTrain,2); % 平均图像/行平均Train_Number = size(imgTrain,2);%列数%计算机每一张图片到均值图像的方差A = []; for i = 1 : Train_Number%对每一列 temp = double(imgTrain(:,i))-m; %每一张图与均值的差异 A = [A temp]; %差矩阵end%得到A的协方差矩阵并转置得到LL = A&#x27;*A; % L是协方差矩阵C=A*A&#x27;的转置%得到特征值与特征向量[V,D] = eig(L); %对角线上的元素是L|C的特征值.V:以特征向量为列的满秩矩阵，D：特征值对角矩阵。即L*V = V*D.L_eig_vec = [];%特征值向量max=0;for i = 1 : size(V,2)%对每个特征向量 max=max+D(i,i);endsum=0;for i = size(V,2):-1:size(V,2)-2%对每个特征向量 L_eig_vec = [L_eig_vec V(:,i)]*0;%集中对应的特征向量 sum=sum+D(i,i);endfor i = size(V,2)-3:-1:size(V,2)-9%对每个特征向量 L_eig_vec = [L_eig_vec V(:,i)]*0.05;%集中对应的特征向量 sum=sum+D(i,i);endfor i = size(V,2)-10:-1:1%对每个特征向量 L_eig_vec = [L_eig_vec V(:,i)];%集中对应的特征向量 sum=sum+D(i,i); if(sum/max&gt;0.99) break; endendEigenfaces = A * L_eig_vec; % 计算机协方差矩阵C的特征向量， %得到降维了的特征,A为每一张图像与均值图像的差构成的矩阵，TrainProjectedImages = [];%映射图像for i = 1 : img_num%对于每一个训练特征 temp = Eigenfaces&#x27;*double(Q(:,i)); TrainProjectedImages = [TrainProjectedImages temp]; %得到 L_eig_vec;end 人脸重建 人脸重建实验的目的是为了测试特征脸所携带的人脸信息。由于特征值的大小代表了其所对应的特征向量所携带的信息量，通过将最大的一些特征值对应的特征向量叠加就可以获得原图像中的大部分信息量，也就是所谓的主成分。这里先将所有特征值按从大到小的顺序排列。通过叠加特征向量的方式，就可以得到一组对原人脸的逼近特征脸。而将特征值加起来，正是总的信息量，也可以求出重构误差。 人脸识别 人脸识别即给出一个待识别的在测试集中的图像，计算该图像与已经有的人脸即训练集中的人脸的距离，距离最小的则认为该图片的人脸。 123456789101112131415161718192021for i=1:Testcols mImgTestCur = TestProjectedImages(:,i); vDisMin = 9999999999999; vClassMin = -1; for j=1:Traincols mImgTrainCur = TrainProjectedImages(:,j); mDis = mImgTestCur-mImgTrainCur; mDis = mDis.^2; vDis = sqrt(sum(mDis)); if vDis&lt;vDisMin vDisMin = vDis; m=j; end end name1=img_path_list_train(m).name; name1 =name1(6:7);%取名字的6-7位置的字符 name2=img_path_list_test(i).name; name2 =name2(6:7); if name2==name1 count=count+1; end 未完待续…","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://example.com/tags/matlab/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"深度优先dfs","slug":"深度优先dfs","date":"2020-11-21T16:57:02.000Z","updated":"2020-11-22T06:47:25.444Z","comments":true,"path":"2020/11/22/深度优先dfs/","link":"","permalink":"http://example.com/2020/11/22/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88dfs/","excerpt":"","text":"d 之所以总结一下dfs，是因为刷python题目时候遇到一个题，单词搜索问题，类似于dfs思想的题目，不太会做，然后就总结一下 什么是DFSDepth First Search英文的缩写，翻译过来就是“深度优先搜索”。 深度优先遍历的主要思想就是：首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点；当没有未访问过的顶点时，则回到上一个顶点，继续试探访问别的顶点，直到所有的顶点都被访问。 沿着某条路径遍历直到末端，然后回溯，再沿着另一条进行同样的遍历，直到所有的顶点都被访问过为止。 即：不撞南墙不回头 算法过程 任意选择一个起点v，访问该顶点 沿深度方向，依次遍历未访问邻节点 tips：每次访问后都要将访问的vist[]变成1 递归伪代码12345678DFS(dep,、、、） &#x2F;&#x2F;dep代表目前DFS的深度&#123; if(找到解 || 走不下去)&#123; 、、、 &#x2F;&#x2F;在此处进行相应的操作 return ; &#125; 枚举下一种情况，DFS（dep+1,、、、）&#125; 非递归伪代码1234567891011121314151617bool visited[MAXNODE]; &#x2F;&#x2F;顶点的访问标识数组void DFSInit(Graph G)&#123; for(i&#x3D;0; i&lt;G.VertexNum; i++)&#123; visited[i] &#x3D; false; &#125;&#125;void DFS(Graph G,int v)&#123; &#x2F;&#x2F;v:顶点数组中的序号 Visit[v]; visited[v]&#x3D;true; w &#x3D; FirstAdj(G,v); &#x2F;&#x2F;返回：v的第一个邻接点，0表示无邻接点 while(w!&#x3D;0)&#123; if(!visited[w]&#123; DFS(G,w); &#x2F;&#x2F;参数传递w-&gt;v &#125; w &#x3D; NextAdj(G,v,w); &#x2F;&#x2F;返回：v的在邻接点w后的邻接点，0表示不存在 &#125;&#125; 其中一种DFS序列：DFS(G,v1) = (v1,v2,v3,v6,v5,v7,v4,v8,v9) 小结dfs即找准了一条路，如果满足判定成功条件或者失败条件（撞南墙）就返回上一个节点，再从这个节点继续找下一个，再撞再回溯。 单词搜索问题12345678910111213def dfs(self,i,j,cmap,word): if len(word)==0: #撞南墙 return True #撞南墙 elif i&gt;=len(cmap) or i&lt;0 or j&lt;0 or j&gt;=len(cmap[0]) or word[0]!=cmap[i][j]: return False temp=cmap[i][j] cmap[i][j]=&#x27;#&#x27; res =self.dfs(i+1,j,cmap,word[1:]) or self.dfs(i-1, j, cmap, word[1:]) or self.dfs(i, j+1, cmap, word[1:]) or self.dfs(i, j-1, cmap, word[1:]) #四种方向，其中有一种return True那这个节点即return True cmap[i][j]=temp return res 未完待续……………………………….","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"关于考研","slug":"postdsa","date":"2020-11-19T07:24:48.000Z","updated":"2020-11-19T07:43:46.425Z","comments":true,"path":"2020/11/19/postdsa/","link":"","permalink":"http://example.com/2020/11/19/postdsa/","excerpt":"","text":"d 现在是2020.11.19，距离大四毕业还有一年半的时间，还有半年我就要面临考研以及还是就业的选择，说实话，我现在是十分犹豫的。 我之所以想考研其实很大部分原因是因为感觉自己其实并没有准备好直接就进入职场经历那雨打风吹，而且读完研究生的薪资待遇确实是和本科生不同，可能是为了“钱途”吧，本来打算保不了研就直接从业的我产生了读研的想法。 关于之后这大半年其实计算机这门学科，只要你肯花时间去专研，琢磨，总结，深入，不停写码肯定可以收获不小的成功，哪怕不能做到最最最顶尖，但肯定是高于水准线之上很多的。我的想法是： 不断地刷题，刷leetcode，现在我把matrix上字节跳动的题目刷完就去刷leetcode了 总结，将知识点分类，或者觉得有用的东西弄到我的blog上，并且不断地美化自己的blog。 总结计网，计组，操作系统，计网的知识点到blog上，并且深入地做一些相关地研究或者实验去加深巩固，而且因为这学期是有计网2这个科目的，所以计网是放在第一优先级的 做一些实际的项目练手 考研科目英语100分 数学150分 政治100分 专业课：150分 数据结构45分，计算机组成原理45分，操作系统35分，计算机网络25分； 试卷题型结构：单项选择题，80分（40小题，每小题2分）；综合题，70分； 加油~愿韶华不负 ​ JAYSON","categories":[{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"}],"tags":[]},{"title":"关于考研","slug":"关于考研","date":"2020-11-19T07:24:48.000Z","updated":"2020-11-19T07:43:46.425Z","comments":true,"path":"2020/11/19/关于考研/","link":"","permalink":"http://example.com/2020/11/19/%E5%85%B3%E4%BA%8E%E8%80%83%E7%A0%94/","excerpt":"","text":"d 现在是2020.11.19，距离大四毕业还有一年半的时间，还有半年我就要面临考研以及还是就业的选择，说实话，我现在是十分犹豫的。 我之所以想考研其实很大部分原因是因为感觉自己其实并没有准备好直接就进入职场经历那雨打风吹，而且读完研究生的薪资待遇确实是和本科生不同，可能是为了“钱途”吧，本来打算保不了研就直接从业的我产生了读研的想法。 关于之后这大半年其实计算机这门学科，只要你肯花时间去专研，琢磨，总结，深入，不停写码肯定可以收获不小的成功，哪怕不能做到最最最顶尖，但肯定是高于水准线之上很多的。我的想法是： 不断地刷题，刷leetcode，现在我把matrix上字节跳动的题目刷完就去刷leetcode了 总结，将知识点分类，或者觉得有用的东西弄到我的blog上，并且不断地美化自己的blog。 总结计网，计组，操作系统，计网的知识点到blog上，并且深入地做一些相关地研究或者实验去加深巩固，而且因为这学期是有计网2这个科目的，所以计网是放在第一优先级的 做一些实际的项目练手 考研科目英语100分 数学150分 政治100分 专业课：150分 数据结构45分，计算机组成原理45分，操作系统35分，计算机网络25分； 试卷题型结构：单项选择题，80分（40小题，每小题2分）；综合题，70分； 加油~愿韶华不负 ​ JAYSON","categories":[{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"}],"tags":[]},{"title":"链表in python","slug":"链表in-python","date":"2020-11-18T18:09:45.000Z","updated":"2020-11-18T18:31:49.555Z","comments":true,"path":"2020/11/19/链表in-python/","link":"","permalink":"http://example.com/2020/11/19/%E9%93%BE%E8%A1%A8in-python/","excerpt":"","text":"链表链表是python中特别重要且实用的数据结构，c++中的链表实现是分为指针和静态的，但因为python中没有指针结构，所以是只有静态的实现 链表节点的定义1234class ListNode: def __init__(self, x): self.val = x self.next = None 节点有两个内置变量，一个是val即储存的值。另一个是next，即指向的下一个节点。 链表的构建12345678910head= ListNode(5)for i in range(1,3): node = ListNode(i) cur = head.next if cur== None: head.next = node else: while cur.next != None: cur = cur.next cur.next = node 理解：头head是指向一个一般不动的，所以你要在头后面加数的话，得先建一个temp=head，然后改变temp在链表的位置使其指向最后一个数，再temp.next=node 链表求和123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 is None: return l2 elif l2 is None: return l1 head1=reverse(l1) head2=reverse(l2) head=None flag=0 while head1 is not None or head2 is not None: if head1 is None: node=ListNode(0) head1=node elif head2 is None: node = ListNode(0) head2 = node sum_num=head1.val+head2.val+flag if sum_num&gt;=10: flag=1 sum_num=sum_num%10 else: flag=0 temp=ListNode(sum_num) if head==None: head=temp else: cur=head while cur.next!=None: cur=cur.next cur.next=temp head1=head1.next head2=head2.next temp=head if flag==1: while temp.next!=None: temp=temp.next temp.next=ListNode(1) head=reverse(head) if head.val==0: head=head.next return head 判断链表是否有环1234567891011121314class Solution: def hasCycle(self, head: ListNode) -&gt; bool: slow_list = head fast_list = head while slow_list.next is not None and fast_list.next is not None: if fast_list.next.next is None: break slow_list=slow_list.next fast_list=fast_list.next.next if slow_list.val==fast_list.val: print(&quot;True&quot;,end=&#x27;&#x27;) return &#x27;&#x27; print(&quot;False&quot;,&#x27;&#x27;) return &#x27;&#x27;","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"基础数据结构list","slug":"lilst","date":"2020-11-16T09:32:51.000Z","updated":"2020-11-19T16:29:14.384Z","comments":true,"path":"2020/11/16/lilst/","link":"","permalink":"http://example.com/2020/11/16/lilst/","excerpt":"","text":"List数据类型是python中最为常用的数据类型，在这里总结一下对list的理解 列表数据类型是python中最为常用的数据类型，在这里总结一下对list的理解，以及常用的操作 List数据类型的理解列表类型与c++的数组和STL的vector十分像，且列表中的元素类型不是固定的，十分有意思。与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。 列表的创建list=[]//创建空列表 list = [‘physics’, ‘chemistry’, 1997, 2000] list=list(range()) 列表的基本操作添加元素在列表的最后一位添加元素 list.append(obj) 插入元素list.insert(index,obj) 移除元素移除列表中一个元素，并返回列表的值，默认是最后一位 list.pop([index=-1]) 列表取反list.reverse() 列表排序该方法没有返回值，但是会对列表的对象进行排序。 list.sort(cmp=None, key=None, reverse=False) 降序vowels.sort(reverse=True) 升序升序是默认的即：list.sort() vowels.sort(reverse=False) 链表切片切片操作确实还是蛮方便的，python中可以很轻易地实现对列表的切割 1list2=list1[a:b] 左闭右开即取a不取b [a:],[:b] #只取一边 其他列表操作 cmp(list1,list2) len(list) max(list) min(list) list(seq)//将元组转换为列表 list.count(obj)//统计某个元素在列表中出现的次数 list.index(obj)//从列表中找出某个值第一个匹配项的索引位置 list.remove(obj)//移除列表中某个值的第一个匹配项 列表的遍历 for i,j in list: for i in range(n): 以上是一些列表的基本操作，一般其实用不到特别复杂的操作，未完待续………","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"numpy","slug":"numpy","date":"2020-11-15T14:32:51.000Z","updated":"2020-11-15T15:00:58.945Z","comments":true,"path":"2020/11/15/numpy/","link":"","permalink":"http://example.com/2020/11/15/numpy/","excerpt":"","text":"[toc] 在数值计算中numpy特别使用，所以做一下关于numpy用法的记录 numpyimport numpy as np ARRAY的创建np.array()e.g. np.array([[1,1,1], ​ [[1,1,1]) np.zeros()#全零的矩阵 e.g. np.zeros([3,3]) np.ones()#全1的矩阵 e.g. np.ones([3,3]) np.empty()#空 e.g. np.empty([3,3]) np.full()e.g. array=np.full([3,3],6) #全是6的3*3矩阵 ARRAY的属性array.shape#几行几列 对于图像来说： ​ img.shape[0]：图像的垂直尺寸（高度） ​ img.shape[1]：图像的水平尺寸（宽度） ​ img.shape[2]：图像的通道数 而对于矩阵来说： ​ shape[0]：表示矩阵的行数 ​ shape[1]：表示矩阵的列数 array.size#大小 array.T#转置 array.real#虚数的实部 array.imag#实数的虚部 ARRAY的操作np.mean()np.mean(arr) #求所有值的均值 np.mean(arr,axis=0)#按列求均值 np.mean(arr,axis=1)#按行求均值 array.copy ()#复制拷贝 e.g. cc=array.copy() ！！！cc=array 这个是浅拷贝，cc改变array也会改变 array.reshape()array.reshape(2,8) #重塑形状，改变数组的行和列 array.resize()#resize()和reshape()的区别是前者数组自身会改变，后者不会 array.flatten#直接将数组拉平编程一维的 array.max()#最大值 np.matmul(a,b)矩阵乘法 np.tile()#将数组沿y或x扩大倍数 np.(a,(2,1))//第一个是y，第二个是x轴 ARRAY的索引切片array[1:3,1:3]#变成1，2行列的数组 #python索引是前面闭括号，后面开括号 键对索引array[[row1,row2],[col1,col2]] #一一对应 e.g. array[[0,2],[1,3]] np.nditer 迭代器e.g. for i in np.nditer(array): ​ print(i) ARRAY的拼接拆分拼接vstack#上下 np.vstack([array1,array2]) hstack#左右 np.hstack([array1,array2]) stack#维度 np.stack([array1,array2]) 拆分vsplithsplitsplit图像的读取库import matplotlib.pyplot as plt import matplotlib.image as mpimg import numpy as np 读取img=mpimg.imread(‘cat.jpg’) #此时 img 就已经是一个 np.array 了，可以对它进行任意处理 showplt.imshow(img) # 显示图片 plt.axis(‘off’) # 不显示坐标轴 plt.show()","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"first_article","slug":"first-article","date":"2020-10-25T16:15:37.000Z","updated":"2020-10-26T04:38:59.911Z","comments":true,"path":"2020/10/26/first-article/","link":"","permalink":"http://example.com/2020/10/26/first-article/","excerpt":"","text":"first第一个blog_text","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-10-25T15:43:49.321Z","updated":"2020-10-25T15:43:49.321Z","comments":true,"path":"2020/10/25/hello-world/","link":"","permalink":"http://example.com/2020/10/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/categories/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数值计算","slug":"数值计算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"未来方向","slug":"未来方向","permalink":"http://example.com/tags/%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"matlab","slug":"matlab","permalink":"http://example.com/tags/matlab/"}]}